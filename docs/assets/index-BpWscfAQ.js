var Mt=Object.defineProperty;var ct=a=>{throw TypeError(a)};var Dt=(a,D,V)=>D in a?Mt(a,D,{enumerable:!0,configurable:!0,writable:!0,value:V}):a[D]=V;var W=(a,D,V)=>Dt(a,typeof D!="symbol"?D+"":D,V),xt=(a,D,V)=>D.has(a)||ct("Cannot "+V);var Rn=(a,D,V)=>(xt(a,D,"read from private field"),V?V.call(a):D.get(a)),rt=(a,D,V)=>D.has(a)?ct("Cannot add the same private member more than once"):D instanceof WeakSet?D.add(a):D.set(a,V);(function(){const D=document.createElement("link").relList;if(D&&D.supports&&D.supports("modulepreload"))return;for(const K of document.querySelectorAll('link[rel="modulepreload"]'))R(K);new MutationObserver(K=>{for(const X of K)if(X.type==="childList")for(const b of X.addedNodes)b.tagName==="LINK"&&b.rel==="modulepreload"&&R(b)}).observe(document,{childList:!0,subtree:!0});function V(K){const X={};return K.integrity&&(X.integrity=K.integrity),K.referrerPolicy&&(X.referrerPolicy=K.referrerPolicy),K.crossOrigin==="use-credentials"?X.credentials="include":K.crossOrigin==="anonymous"?X.credentials="omit":X.credentials="same-origin",X}function R(K){if(K.ep)return;K.ep=!0;const X=V(K);fetch(K.href,X)}})();function yt(a,D){return class extends a{constructor(...V){super(...V),D(this)}}}const mt=yt(Array,a=>a.fill(0));let N=1e-6;function vt(a){const D=N;return N=a,D}function zt(a){return a*Math.PI/180}function At(a){return a*180/Math.PI}function St(a,D,V){return a+(D-a)*V}function Tt(a,D,V){const R=D-a;return Math.abs(D-a)<N?a:(V-a)/R}function Pt(a,D){return(a%D+D)%D}var kn={__proto__:null,get EPSILON(){return N},degToRad:zt,euclideanModulo:Pt,inverseLerp:Tt,lerp:St,radToDeg:At,setEpsilon:vt};function _t(a){function D(n=0,o=0){const t=new a(2);return n!==void 0&&(t[0]=n,o!==void 0&&(t[1]=o)),t}const V=D;function R(n,o,t){const e=t??new a(2);return e[0]=n,e[1]=o,e}function K(n,o){const t=o??new a(2);return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t}function X(n,o){const t=o??new a(2);return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t}function b(n,o){const t=o??new a(2);return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t}function on(n,o=0,t=1,e){const u=e??new a(2);return u[0]=Math.min(t,Math.max(o,n[0])),u[1]=Math.min(t,Math.max(o,n[1])),u}function Mn(n,o,t){const e=t??new a(2);return e[0]=n[0]+o[0],e[1]=n[1]+o[1],e}function Tn(n,o,t,e){const u=e??new a(2);return u[0]=n[0]+o[0]*t,u[1]=n[1]+o[1]*t,u}function Pn(n,o){const t=n[0],e=n[1],u=o[0],p=o[1],m=Math.sqrt(t*t+e*e),s=Math.sqrt(u*u+p*p),i=m*s,h=i&&mn(n,o)/i;return Math.acos(h)}function cn(n,o,t){const e=t??new a(2);return e[0]=n[0]-o[0],e[1]=n[1]-o[1],e}const _n=cn;function rn(n,o){return Math.abs(n[0]-o[0])<N&&Math.abs(n[1]-o[1])<N}function qn(n,o){return n[0]===o[0]&&n[1]===o[1]}function un(n,o,t,e){const u=e??new a(2);return u[0]=n[0]+t*(o[0]-n[0]),u[1]=n[1]+t*(o[1]-n[1]),u}function J(n,o,t,e){const u=e??new a(2);return u[0]=n[0]+t[0]*(o[0]-n[0]),u[1]=n[1]+t[1]*(o[1]-n[1]),u}function On(n,o,t){const e=t??new a(2);return e[0]=Math.max(n[0],o[0]),e[1]=Math.max(n[1],o[1]),e}function fn(n,o,t){const e=t??new a(2);return e[0]=Math.min(n[0],o[0]),e[1]=Math.min(n[1],o[1]),e}function C(n,o,t){const e=t??new a(2);return e[0]=n[0]*o,e[1]=n[1]*o,e}const Un=C;function Dn(n,o,t){const e=t??new a(2);return e[0]=n[0]/o,e[1]=n[1]/o,e}function xn(n,o){const t=o??new a(2);return t[0]=1/n[0],t[1]=1/n[1],t}const Vn=xn;function yn(n,o,t){const e=t??new a(3),u=n[0]*o[1]-n[1]*o[0];return e[0]=0,e[1]=0,e[2]=u,e}function mn(n,o){return n[0]*o[0]+n[1]*o[1]}function nn(n){const o=n[0],t=n[1];return Math.sqrt(o*o+t*t)}const Bn=nn;function j(n){const o=n[0],t=n[1];return o*o+t*t}const Z=j;function k(n,o){const t=n[0]-o[0],e=n[1]-o[1];return Math.sqrt(t*t+e*e)}const f=k;function S(n,o){const t=n[0]-o[0],e=n[1]-o[1];return t*t+e*e}const M=S;function v(n,o){const t=o??new a(2),e=n[0],u=n[1],p=Math.sqrt(e*e+u*u);return p>1e-5?(t[0]=e/p,t[1]=u/p):(t[0]=0,t[1]=0),t}function _(n,o){const t=o??new a(2);return t[0]=-n[0],t[1]=-n[1],t}function P(n,o){const t=o??new a(2);return t[0]=n[0],t[1]=n[1],t}const F=P;function E(n,o,t){const e=t??new a(2);return e[0]=n[0]*o[0],e[1]=n[1]*o[1],e}const I=E;function q(n,o,t){const e=t??new a(2);return e[0]=n[0]/o[0],e[1]=n[1]/o[1],e}const L=q;function $(n=1,o){const t=o??new a(2),e=Math.random()*2*Math.PI;return t[0]=Math.cos(e)*n,t[1]=Math.sin(e)*n,t}function g(n){const o=n??new a(2);return o[0]=0,o[1]=0,o}function A(n,o,t){const e=t??new a(2),u=n[0],p=n[1];return e[0]=u*o[0]+p*o[4]+o[12],e[1]=u*o[1]+p*o[5]+o[13],e}function c(n,o,t){const e=t??new a(2),u=n[0],p=n[1];return e[0]=o[0]*u+o[4]*p+o[8],e[1]=o[1]*u+o[5]*p+o[9],e}function r(n,o,t,e){const u=e??new a(2),p=n[0]-o[0],m=n[1]-o[1],s=Math.sin(t),i=Math.cos(t);return u[0]=p*i-m*s+o[0],u[1]=p*s+m*i+o[1],u}function l(n,o,t){const e=t??new a(2);return v(n,e),C(e,o,e)}function d(n,o,t){const e=t??new a(2);return nn(n)>o?l(n,o,e):P(n,e)}function T(n,o,t){const e=t??new a(2);return un(n,o,.5,e)}return{create:D,fromValues:V,set:R,ceil:K,floor:X,round:b,clamp:on,add:Mn,addScaled:Tn,angle:Pn,subtract:cn,sub:_n,equalsApproximately:rn,equals:qn,lerp:un,lerpV:J,max:On,min:fn,mulScalar:C,scale:Un,divScalar:Dn,inverse:xn,invert:Vn,cross:yn,dot:mn,length:nn,len:Bn,lengthSq:j,lenSq:Z,distance:k,dist:f,distanceSq:S,distSq:M,normalize:v,negate:_,copy:P,clone:F,multiply:E,mul:I,divide:q,div:L,random:$,zero:g,transformMat4:A,transformMat3:c,rotate:r,setLength:l,truncate:d,midpoint:T}}const it=new Map;function gt(a){let D=it.get(a);return D||(D=_t(a),it.set(a,D)),D}function qt(a){const D=gt(a);function V(f,S,M,v,_,P,F,E,I){const q=new a(12);return q[3]=0,q[7]=0,q[11]=0,f!==void 0&&(q[0]=f,S!==void 0&&(q[1]=S,M!==void 0&&(q[2]=M,v!==void 0&&(q[4]=v,_!==void 0&&(q[5]=_,P!==void 0&&(q[6]=P,F!==void 0&&(q[8]=F,E!==void 0&&(q[9]=E,I!==void 0&&(q[10]=I))))))))),q}function R(f,S,M,v,_,P,F,E,I,q){const L=q??new a(12);return L[0]=f,L[1]=S,L[2]=M,L[3]=0,L[4]=v,L[5]=_,L[6]=P,L[7]=0,L[8]=F,L[9]=E,L[10]=I,L[11]=0,L}function K(f,S){const M=S??new a(12);return M[0]=f[0],M[1]=f[1],M[2]=f[2],M[3]=0,M[4]=f[4],M[5]=f[5],M[6]=f[6],M[7]=0,M[8]=f[8],M[9]=f[9],M[10]=f[10],M[11]=0,M}function X(f,S){const M=S??new a(12),v=f[0],_=f[1],P=f[2],F=f[3],E=v+v,I=_+_,q=P+P,L=v*E,$=_*E,g=_*I,A=P*E,c=P*I,r=P*q,l=F*E,d=F*I,T=F*q;return M[0]=1-g-r,M[1]=$+T,M[2]=A-d,M[3]=0,M[4]=$-T,M[5]=1-L-r,M[6]=c+l,M[7]=0,M[8]=A+d,M[9]=c-l,M[10]=1-L-g,M[11]=0,M}function b(f,S){const M=S??new a(12);return M[0]=-f[0],M[1]=-f[1],M[2]=-f[2],M[4]=-f[4],M[5]=-f[5],M[6]=-f[6],M[8]=-f[8],M[9]=-f[9],M[10]=-f[10],M}function on(f,S){const M=S??new a(12);return M[0]=f[0],M[1]=f[1],M[2]=f[2],M[4]=f[4],M[5]=f[5],M[6]=f[6],M[8]=f[8],M[9]=f[9],M[10]=f[10],M}const Mn=on;function Tn(f,S){return Math.abs(f[0]-S[0])<N&&Math.abs(f[1]-S[1])<N&&Math.abs(f[2]-S[2])<N&&Math.abs(f[4]-S[4])<N&&Math.abs(f[5]-S[5])<N&&Math.abs(f[6]-S[6])<N&&Math.abs(f[8]-S[8])<N&&Math.abs(f[9]-S[9])<N&&Math.abs(f[10]-S[10])<N}function Pn(f,S){return f[0]===S[0]&&f[1]===S[1]&&f[2]===S[2]&&f[4]===S[4]&&f[5]===S[5]&&f[6]===S[6]&&f[8]===S[8]&&f[9]===S[9]&&f[10]===S[10]}function cn(f){const S=f??new a(12);return S[0]=1,S[1]=0,S[2]=0,S[4]=0,S[5]=1,S[6]=0,S[8]=0,S[9]=0,S[10]=1,S}function _n(f,S){const M=S??new a(12);if(M===f){let g;return g=f[1],f[1]=f[4],f[4]=g,g=f[2],f[2]=f[8],f[8]=g,g=f[6],f[6]=f[9],f[9]=g,M}const v=f[0*4+0],_=f[0*4+1],P=f[0*4+2],F=f[1*4+0],E=f[1*4+1],I=f[1*4+2],q=f[2*4+0],L=f[2*4+1],$=f[2*4+2];return M[0]=v,M[1]=F,M[2]=q,M[4]=_,M[5]=E,M[6]=L,M[8]=P,M[9]=I,M[10]=$,M}function rn(f,S){const M=S??new a(12),v=f[0*4+0],_=f[0*4+1],P=f[0*4+2],F=f[1*4+0],E=f[1*4+1],I=f[1*4+2],q=f[2*4+0],L=f[2*4+1],$=f[2*4+2],g=$*E-I*L,A=-$*F+I*q,c=L*F-E*q,r=1/(v*g+_*A+P*c);return M[0]=g*r,M[1]=(-$*_+P*L)*r,M[2]=(I*_-P*E)*r,M[4]=A*r,M[5]=($*v-P*q)*r,M[6]=(-I*v+P*F)*r,M[8]=c*r,M[9]=(-L*v+_*q)*r,M[10]=(E*v-_*F)*r,M}function qn(f){const S=f[0],M=f[0*4+1],v=f[0*4+2],_=f[1*4+0],P=f[1*4+1],F=f[1*4+2],E=f[2*4+0],I=f[2*4+1],q=f[2*4+2];return S*(P*q-I*F)-_*(M*q-I*v)+E*(M*F-P*v)}const un=rn;function J(f,S,M){const v=M??new a(12),_=f[0],P=f[1],F=f[2],E=f[4],I=f[5],q=f[6],L=f[8],$=f[9],g=f[10],A=S[0],c=S[1],r=S[2],l=S[4],d=S[5],T=S[6],n=S[8],o=S[9],t=S[10];return v[0]=_*A+E*c+L*r,v[1]=P*A+I*c+$*r,v[2]=F*A+q*c+g*r,v[4]=_*l+E*d+L*T,v[5]=P*l+I*d+$*T,v[6]=F*l+q*d+g*T,v[8]=_*n+E*o+L*t,v[9]=P*n+I*o+$*t,v[10]=F*n+q*o+g*t,v}const On=J;function fn(f,S,M){const v=M??cn();return f!==v&&(v[0]=f[0],v[1]=f[1],v[2]=f[2],v[4]=f[4],v[5]=f[5],v[6]=f[6]),v[8]=S[0],v[9]=S[1],v[10]=1,v}function C(f,S){const M=S??D.create();return M[0]=f[8],M[1]=f[9],M}function Un(f,S,M){const v=M??D.create(),_=S*4;return v[0]=f[_+0],v[1]=f[_+1],v}function Dn(f,S,M,v){const _=v===f?f:on(f,v),P=M*4;return _[P+0]=S[0],_[P+1]=S[1],_}function xn(f,S){const M=S??D.create(),v=f[0],_=f[1],P=f[4],F=f[5];return M[0]=Math.sqrt(v*v+_*_),M[1]=Math.sqrt(P*P+F*F),M}function Vn(f,S){const M=S??new a(12);return M[0]=1,M[1]=0,M[2]=0,M[4]=0,M[5]=1,M[6]=0,M[8]=f[0],M[9]=f[1],M[10]=1,M}function yn(f,S,M){const v=M??new a(12),_=S[0],P=S[1],F=f[0],E=f[1],I=f[2],q=f[1*4+0],L=f[1*4+1],$=f[1*4+2],g=f[2*4+0],A=f[2*4+1],c=f[2*4+2];return f!==v&&(v[0]=F,v[1]=E,v[2]=I,v[4]=q,v[5]=L,v[6]=$),v[8]=F*_+q*P+g,v[9]=E*_+L*P+A,v[10]=I*_+$*P+c,v}function mn(f,S){const M=S??new a(12),v=Math.cos(f),_=Math.sin(f);return M[0]=v,M[1]=_,M[2]=0,M[4]=-_,M[5]=v,M[6]=0,M[8]=0,M[9]=0,M[10]=1,M}function nn(f,S,M){const v=M??new a(12),_=f[0*4+0],P=f[0*4+1],F=f[0*4+2],E=f[1*4+0],I=f[1*4+1],q=f[1*4+2],L=Math.cos(S),$=Math.sin(S);return v[0]=L*_+$*E,v[1]=L*P+$*I,v[2]=L*F+$*q,v[4]=L*E-$*_,v[5]=L*I-$*P,v[6]=L*q-$*F,f!==v&&(v[8]=f[8],v[9]=f[9],v[10]=f[10]),v}function Bn(f,S){const M=S??new a(12);return M[0]=f[0],M[1]=0,M[2]=0,M[4]=0,M[5]=f[1],M[6]=0,M[8]=0,M[9]=0,M[10]=1,M}function j(f,S,M){const v=M??new a(12),_=S[0],P=S[1];return v[0]=_*f[0*4+0],v[1]=_*f[0*4+1],v[2]=_*f[0*4+2],v[4]=P*f[1*4+0],v[5]=P*f[1*4+1],v[6]=P*f[1*4+2],f!==v&&(v[8]=f[8],v[9]=f[9],v[10]=f[10]),v}function Z(f,S){const M=S??new a(12);return M[0]=f,M[1]=0,M[2]=0,M[4]=0,M[5]=f,M[6]=0,M[8]=0,M[9]=0,M[10]=1,M}function k(f,S,M){const v=M??new a(12);return v[0]=S*f[0*4+0],v[1]=S*f[0*4+1],v[2]=S*f[0*4+2],v[4]=S*f[1*4+0],v[5]=S*f[1*4+1],v[6]=S*f[1*4+2],f!==v&&(v[8]=f[8],v[9]=f[9],v[10]=f[10]),v}return{clone:Mn,create:V,set:R,fromMat4:K,fromQuat:X,negate:b,copy:on,equalsApproximately:Tn,equals:Pn,identity:cn,transpose:_n,inverse:rn,invert:un,determinant:qn,mul:On,multiply:J,setTranslation:fn,getTranslation:C,getAxis:Un,setAxis:Dn,getScaling:xn,translation:Vn,translate:yn,rotation:mn,rotate:nn,scaling:Bn,scale:j,uniformScaling:Z,uniformScale:k}}const ut=new Map;function Ot(a){let D=ut.get(a);return D||(D=qt(a),ut.set(a,D)),D}function Vt(a){function D(s,i,h){const w=new a(3);return s!==void 0&&(w[0]=s,i!==void 0&&(w[1]=i,h!==void 0&&(w[2]=h))),w}const V=D;function R(s,i,h,w){const x=w??new a(3);return x[0]=s,x[1]=i,x[2]=h,x}function K(s,i){const h=i??new a(3);return h[0]=Math.ceil(s[0]),h[1]=Math.ceil(s[1]),h[2]=Math.ceil(s[2]),h}function X(s,i){const h=i??new a(3);return h[0]=Math.floor(s[0]),h[1]=Math.floor(s[1]),h[2]=Math.floor(s[2]),h}function b(s,i){const h=i??new a(3);return h[0]=Math.round(s[0]),h[1]=Math.round(s[1]),h[2]=Math.round(s[2]),h}function on(s,i=0,h=1,w){const x=w??new a(3);return x[0]=Math.min(h,Math.max(i,s[0])),x[1]=Math.min(h,Math.max(i,s[1])),x[2]=Math.min(h,Math.max(i,s[2])),x}function Mn(s,i,h){const w=h??new a(3);return w[0]=s[0]+i[0],w[1]=s[1]+i[1],w[2]=s[2]+i[2],w}function Tn(s,i,h,w){const x=w??new a(3);return x[0]=s[0]+i[0]*h,x[1]=s[1]+i[1]*h,x[2]=s[2]+i[2]*h,x}function Pn(s,i){const h=s[0],w=s[1],x=s[2],y=i[0],z=i[1],B=i[2],G=Math.sqrt(h*h+w*w+x*x),O=Math.sqrt(y*y+z*z+B*B),U=G*O,Y=U&&mn(s,i)/U;return Math.acos(Y)}function cn(s,i,h){const w=h??new a(3);return w[0]=s[0]-i[0],w[1]=s[1]-i[1],w[2]=s[2]-i[2],w}const _n=cn;function rn(s,i){return Math.abs(s[0]-i[0])<N&&Math.abs(s[1]-i[1])<N&&Math.abs(s[2]-i[2])<N}function qn(s,i){return s[0]===i[0]&&s[1]===i[1]&&s[2]===i[2]}function un(s,i,h,w){const x=w??new a(3);return x[0]=s[0]+h*(i[0]-s[0]),x[1]=s[1]+h*(i[1]-s[1]),x[2]=s[2]+h*(i[2]-s[2]),x}function J(s,i,h,w){const x=w??new a(3);return x[0]=s[0]+h[0]*(i[0]-s[0]),x[1]=s[1]+h[1]*(i[1]-s[1]),x[2]=s[2]+h[2]*(i[2]-s[2]),x}function On(s,i,h){const w=h??new a(3);return w[0]=Math.max(s[0],i[0]),w[1]=Math.max(s[1],i[1]),w[2]=Math.max(s[2],i[2]),w}function fn(s,i,h){const w=h??new a(3);return w[0]=Math.min(s[0],i[0]),w[1]=Math.min(s[1],i[1]),w[2]=Math.min(s[2],i[2]),w}function C(s,i,h){const w=h??new a(3);return w[0]=s[0]*i,w[1]=s[1]*i,w[2]=s[2]*i,w}const Un=C;function Dn(s,i,h){const w=h??new a(3);return w[0]=s[0]/i,w[1]=s[1]/i,w[2]=s[2]/i,w}function xn(s,i){const h=i??new a(3);return h[0]=1/s[0],h[1]=1/s[1],h[2]=1/s[2],h}const Vn=xn;function yn(s,i,h){const w=h??new a(3),x=s[2]*i[0]-s[0]*i[2],y=s[0]*i[1]-s[1]*i[0];return w[0]=s[1]*i[2]-s[2]*i[1],w[1]=x,w[2]=y,w}function mn(s,i){return s[0]*i[0]+s[1]*i[1]+s[2]*i[2]}function nn(s){const i=s[0],h=s[1],w=s[2];return Math.sqrt(i*i+h*h+w*w)}const Bn=nn;function j(s){const i=s[0],h=s[1],w=s[2];return i*i+h*h+w*w}const Z=j;function k(s,i){const h=s[0]-i[0],w=s[1]-i[1],x=s[2]-i[2];return Math.sqrt(h*h+w*w+x*x)}const f=k;function S(s,i){const h=s[0]-i[0],w=s[1]-i[1],x=s[2]-i[2];return h*h+w*w+x*x}const M=S;function v(s,i){const h=i??new a(3),w=s[0],x=s[1],y=s[2],z=Math.sqrt(w*w+x*x+y*y);return z>1e-5?(h[0]=w/z,h[1]=x/z,h[2]=y/z):(h[0]=0,h[1]=0,h[2]=0),h}function _(s,i){const h=i??new a(3);return h[0]=-s[0],h[1]=-s[1],h[2]=-s[2],h}function P(s,i){const h=i??new a(3);return h[0]=s[0],h[1]=s[1],h[2]=s[2],h}const F=P;function E(s,i,h){const w=h??new a(3);return w[0]=s[0]*i[0],w[1]=s[1]*i[1],w[2]=s[2]*i[2],w}const I=E;function q(s,i,h){const w=h??new a(3);return w[0]=s[0]/i[0],w[1]=s[1]/i[1],w[2]=s[2]/i[2],w}const L=q;function $(s=1,i){const h=i??new a(3),w=Math.random()*2*Math.PI,x=Math.random()*2-1,y=Math.sqrt(1-x*x)*s;return h[0]=Math.cos(w)*y,h[1]=Math.sin(w)*y,h[2]=x*s,h}function g(s){const i=s??new a(3);return i[0]=0,i[1]=0,i[2]=0,i}function A(s,i,h){const w=h??new a(3),x=s[0],y=s[1],z=s[2],B=i[3]*x+i[7]*y+i[11]*z+i[15]||1;return w[0]=(i[0]*x+i[4]*y+i[8]*z+i[12])/B,w[1]=(i[1]*x+i[5]*y+i[9]*z+i[13])/B,w[2]=(i[2]*x+i[6]*y+i[10]*z+i[14])/B,w}function c(s,i,h){const w=h??new a(3),x=s[0],y=s[1],z=s[2];return w[0]=x*i[0*4+0]+y*i[1*4+0]+z*i[2*4+0],w[1]=x*i[0*4+1]+y*i[1*4+1]+z*i[2*4+1],w[2]=x*i[0*4+2]+y*i[1*4+2]+z*i[2*4+2],w}function r(s,i,h){const w=h??new a(3),x=s[0],y=s[1],z=s[2];return w[0]=x*i[0]+y*i[4]+z*i[8],w[1]=x*i[1]+y*i[5]+z*i[9],w[2]=x*i[2]+y*i[6]+z*i[10],w}function l(s,i,h){const w=h??new a(3),x=i[0],y=i[1],z=i[2],B=i[3]*2,G=s[0],O=s[1],U=s[2],Y=y*U-z*O,H=z*G-x*U,Q=x*O-y*G;return w[0]=G+Y*B+(y*Q-z*H)*2,w[1]=O+H*B+(z*Y-x*Q)*2,w[2]=U+Q*B+(x*H-y*Y)*2,w}function d(s,i){const h=i??new a(3);return h[0]=s[12],h[1]=s[13],h[2]=s[14],h}function T(s,i,h){const w=h??new a(3),x=i*4;return w[0]=s[x+0],w[1]=s[x+1],w[2]=s[x+2],w}function n(s,i){const h=i??new a(3),w=s[0],x=s[1],y=s[2],z=s[4],B=s[5],G=s[6],O=s[8],U=s[9],Y=s[10];return h[0]=Math.sqrt(w*w+x*x+y*y),h[1]=Math.sqrt(z*z+B*B+G*G),h[2]=Math.sqrt(O*O+U*U+Y*Y),h}function o(s,i,h,w){const x=w??new a(3),y=[],z=[];return y[0]=s[0]-i[0],y[1]=s[1]-i[1],y[2]=s[2]-i[2],z[0]=y[0],z[1]=y[1]*Math.cos(h)-y[2]*Math.sin(h),z[2]=y[1]*Math.sin(h)+y[2]*Math.cos(h),x[0]=z[0]+i[0],x[1]=z[1]+i[1],x[2]=z[2]+i[2],x}function t(s,i,h,w){const x=w??new a(3),y=[],z=[];return y[0]=s[0]-i[0],y[1]=s[1]-i[1],y[2]=s[2]-i[2],z[0]=y[2]*Math.sin(h)+y[0]*Math.cos(h),z[1]=y[1],z[2]=y[2]*Math.cos(h)-y[0]*Math.sin(h),x[0]=z[0]+i[0],x[1]=z[1]+i[1],x[2]=z[2]+i[2],x}function e(s,i,h,w){const x=w??new a(3),y=[],z=[];return y[0]=s[0]-i[0],y[1]=s[1]-i[1],y[2]=s[2]-i[2],z[0]=y[0]*Math.cos(h)-y[1]*Math.sin(h),z[1]=y[0]*Math.sin(h)+y[1]*Math.cos(h),z[2]=y[2],x[0]=z[0]+i[0],x[1]=z[1]+i[1],x[2]=z[2]+i[2],x}function u(s,i,h){const w=h??new a(3);return v(s,w),C(w,i,w)}function p(s,i,h){const w=h??new a(3);return nn(s)>i?u(s,i,w):P(s,w)}function m(s,i,h){const w=h??new a(3);return un(s,i,.5,w)}return{create:D,fromValues:V,set:R,ceil:K,floor:X,round:b,clamp:on,add:Mn,addScaled:Tn,angle:Pn,subtract:cn,sub:_n,equalsApproximately:rn,equals:qn,lerp:un,lerpV:J,max:On,min:fn,mulScalar:C,scale:Un,divScalar:Dn,inverse:xn,invert:Vn,cross:yn,dot:mn,length:nn,len:Bn,lengthSq:j,lenSq:Z,distance:k,dist:f,distanceSq:S,distSq:M,normalize:v,negate:_,copy:P,clone:F,multiply:E,mul:I,divide:q,div:L,random:$,zero:g,transformMat4:A,transformMat4Upper3x3:c,transformMat3:r,transformQuat:l,getTranslation:d,getAxis:T,getScaling:n,rotateX:o,rotateY:t,rotateZ:e,setLength:u,truncate:p,midpoint:m}}const at=new Map;function Cn(a){let D=at.get(a);return D||(D=Vt(a),at.set(a,D)),D}function Ut(a){const D=Cn(a);function V(n,o,t,e,u,p,m,s,i,h,w,x,y,z,B,G){const O=new a(16);return n!==void 0&&(O[0]=n,o!==void 0&&(O[1]=o,t!==void 0&&(O[2]=t,e!==void 0&&(O[3]=e,u!==void 0&&(O[4]=u,p!==void 0&&(O[5]=p,m!==void 0&&(O[6]=m,s!==void 0&&(O[7]=s,i!==void 0&&(O[8]=i,h!==void 0&&(O[9]=h,w!==void 0&&(O[10]=w,x!==void 0&&(O[11]=x,y!==void 0&&(O[12]=y,z!==void 0&&(O[13]=z,B!==void 0&&(O[14]=B,G!==void 0&&(O[15]=G)))))))))))))))),O}function R(n,o,t,e,u,p,m,s,i,h,w,x,y,z,B,G,O){const U=O??new a(16);return U[0]=n,U[1]=o,U[2]=t,U[3]=e,U[4]=u,U[5]=p,U[6]=m,U[7]=s,U[8]=i,U[9]=h,U[10]=w,U[11]=x,U[12]=y,U[13]=z,U[14]=B,U[15]=G,U}function K(n,o){const t=o??new a(16);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=0,t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=0,t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function X(n,o){const t=o??new a(16),e=n[0],u=n[1],p=n[2],m=n[3],s=e+e,i=u+u,h=p+p,w=e*s,x=u*s,y=u*i,z=p*s,B=p*i,G=p*h,O=m*s,U=m*i,Y=m*h;return t[0]=1-y-G,t[1]=x+Y,t[2]=z-U,t[3]=0,t[4]=x-Y,t[5]=1-w-G,t[6]=B+O,t[7]=0,t[8]=z+U,t[9]=B-O,t[10]=1-w-y,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function b(n,o){const t=o??new a(16);return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t[4]=-n[4],t[5]=-n[5],t[6]=-n[6],t[7]=-n[7],t[8]=-n[8],t[9]=-n[9],t[10]=-n[10],t[11]=-n[11],t[12]=-n[12],t[13]=-n[13],t[14]=-n[14],t[15]=-n[15],t}function on(n,o){const t=o??new a(16);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t}const Mn=on;function Tn(n,o){return Math.abs(n[0]-o[0])<N&&Math.abs(n[1]-o[1])<N&&Math.abs(n[2]-o[2])<N&&Math.abs(n[3]-o[3])<N&&Math.abs(n[4]-o[4])<N&&Math.abs(n[5]-o[5])<N&&Math.abs(n[6]-o[6])<N&&Math.abs(n[7]-o[7])<N&&Math.abs(n[8]-o[8])<N&&Math.abs(n[9]-o[9])<N&&Math.abs(n[10]-o[10])<N&&Math.abs(n[11]-o[11])<N&&Math.abs(n[12]-o[12])<N&&Math.abs(n[13]-o[13])<N&&Math.abs(n[14]-o[14])<N&&Math.abs(n[15]-o[15])<N}function Pn(n,o){return n[0]===o[0]&&n[1]===o[1]&&n[2]===o[2]&&n[3]===o[3]&&n[4]===o[4]&&n[5]===o[5]&&n[6]===o[6]&&n[7]===o[7]&&n[8]===o[8]&&n[9]===o[9]&&n[10]===o[10]&&n[11]===o[11]&&n[12]===o[12]&&n[13]===o[13]&&n[14]===o[14]&&n[15]===o[15]}function cn(n){const o=n??new a(16);return o[0]=1,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=1,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1,o[11]=0,o[12]=0,o[13]=0,o[14]=0,o[15]=1,o}function _n(n,o){const t=o??new a(16);if(t===n){let H;return H=n[1],n[1]=n[4],n[4]=H,H=n[2],n[2]=n[8],n[8]=H,H=n[3],n[3]=n[12],n[12]=H,H=n[6],n[6]=n[9],n[9]=H,H=n[7],n[7]=n[13],n[13]=H,H=n[11],n[11]=n[14],n[14]=H,t}const e=n[0*4+0],u=n[0*4+1],p=n[0*4+2],m=n[0*4+3],s=n[1*4+0],i=n[1*4+1],h=n[1*4+2],w=n[1*4+3],x=n[2*4+0],y=n[2*4+1],z=n[2*4+2],B=n[2*4+3],G=n[3*4+0],O=n[3*4+1],U=n[3*4+2],Y=n[3*4+3];return t[0]=e,t[1]=s,t[2]=x,t[3]=G,t[4]=u,t[5]=i,t[6]=y,t[7]=O,t[8]=p,t[9]=h,t[10]=z,t[11]=U,t[12]=m,t[13]=w,t[14]=B,t[15]=Y,t}function rn(n,o){const t=o??new a(16),e=n[0*4+0],u=n[0*4+1],p=n[0*4+2],m=n[0*4+3],s=n[1*4+0],i=n[1*4+1],h=n[1*4+2],w=n[1*4+3],x=n[2*4+0],y=n[2*4+1],z=n[2*4+2],B=n[2*4+3],G=n[3*4+0],O=n[3*4+1],U=n[3*4+2],Y=n[3*4+3],H=z*Y,Q=U*B,tn=h*Y,en=U*w,an=h*B,ln=z*w,hn=p*Y,wn=U*m,dn=p*B,pn=z*m,vn=p*w,zn=h*m,An=x*O,Sn=G*y,In=s*O,Ln=G*i,En=s*y,$n=x*i,Yn=e*O,jn=G*u,Hn=e*y,Xn=x*u,Zn=e*i,Wn=s*u,tt=H*i+en*y+an*O-(Q*i+tn*y+ln*O),et=Q*u+hn*y+pn*O-(H*u+wn*y+dn*O),st=tn*u+wn*i+vn*O-(en*u+hn*i+zn*O),ot=ln*u+dn*i+zn*y-(an*u+pn*i+vn*y),gn=1/(e*tt+s*et+x*st+G*ot);return t[0]=gn*tt,t[1]=gn*et,t[2]=gn*st,t[3]=gn*ot,t[4]=gn*(Q*s+tn*x+ln*G-(H*s+en*x+an*G)),t[5]=gn*(H*e+wn*x+dn*G-(Q*e+hn*x+pn*G)),t[6]=gn*(en*e+hn*s+zn*G-(tn*e+wn*s+vn*G)),t[7]=gn*(an*e+pn*s+vn*x-(ln*e+dn*s+zn*x)),t[8]=gn*(An*w+Ln*B+En*Y-(Sn*w+In*B+$n*Y)),t[9]=gn*(Sn*m+Yn*B+Xn*Y-(An*m+jn*B+Hn*Y)),t[10]=gn*(In*m+jn*w+Zn*Y-(Ln*m+Yn*w+Wn*Y)),t[11]=gn*($n*m+Hn*w+Wn*B-(En*m+Xn*w+Zn*B)),t[12]=gn*(In*z+$n*U+Sn*h-(En*U+An*h+Ln*z)),t[13]=gn*(Hn*U+An*p+jn*z-(Yn*z+Xn*U+Sn*p)),t[14]=gn*(Yn*h+Wn*U+Ln*p-(Zn*U+In*p+jn*h)),t[15]=gn*(Zn*z+En*p+Xn*h-(Hn*h+Wn*z+$n*p)),t}function qn(n){const o=n[0],t=n[0*4+1],e=n[0*4+2],u=n[0*4+3],p=n[1*4+0],m=n[1*4+1],s=n[1*4+2],i=n[1*4+3],h=n[2*4+0],w=n[2*4+1],x=n[2*4+2],y=n[2*4+3],z=n[3*4+0],B=n[3*4+1],G=n[3*4+2],O=n[3*4+3],U=x*O,Y=G*y,H=s*O,Q=G*i,tn=s*y,en=x*i,an=e*O,ln=G*u,hn=e*y,wn=x*u,dn=e*i,pn=s*u,vn=U*m+Q*w+tn*B-(Y*m+H*w+en*B),zn=Y*t+an*w+wn*B-(U*t+ln*w+hn*B),An=H*t+ln*m+dn*B-(Q*t+an*m+pn*B),Sn=en*t+hn*m+pn*w-(tn*t+wn*m+dn*w);return o*vn+p*zn+h*An+z*Sn}const un=rn;function J(n,o,t){const e=t??new a(16),u=n[0],p=n[1],m=n[2],s=n[3],i=n[4],h=n[5],w=n[6],x=n[7],y=n[8],z=n[9],B=n[10],G=n[11],O=n[12],U=n[13],Y=n[14],H=n[15],Q=o[0],tn=o[1],en=o[2],an=o[3],ln=o[4],hn=o[5],wn=o[6],dn=o[7],pn=o[8],vn=o[9],zn=o[10],An=o[11],Sn=o[12],In=o[13],Ln=o[14],En=o[15];return e[0]=u*Q+i*tn+y*en+O*an,e[1]=p*Q+h*tn+z*en+U*an,e[2]=m*Q+w*tn+B*en+Y*an,e[3]=s*Q+x*tn+G*en+H*an,e[4]=u*ln+i*hn+y*wn+O*dn,e[5]=p*ln+h*hn+z*wn+U*dn,e[6]=m*ln+w*hn+B*wn+Y*dn,e[7]=s*ln+x*hn+G*wn+H*dn,e[8]=u*pn+i*vn+y*zn+O*An,e[9]=p*pn+h*vn+z*zn+U*An,e[10]=m*pn+w*vn+B*zn+Y*An,e[11]=s*pn+x*vn+G*zn+H*An,e[12]=u*Sn+i*In+y*Ln+O*En,e[13]=p*Sn+h*In+z*Ln+U*En,e[14]=m*Sn+w*In+B*Ln+Y*En,e[15]=s*Sn+x*In+G*Ln+H*En,e}const On=J;function fn(n,o,t){const e=t??cn();return n!==e&&(e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11]),e[12]=o[0],e[13]=o[1],e[14]=o[2],e[15]=1,e}function C(n,o){const t=o??D.create();return t[0]=n[12],t[1]=n[13],t[2]=n[14],t}function Un(n,o,t){const e=t??D.create(),u=o*4;return e[0]=n[u+0],e[1]=n[u+1],e[2]=n[u+2],e}function Dn(n,o,t,e){const u=e===n?e:on(n,e),p=t*4;return u[p+0]=o[0],u[p+1]=o[1],u[p+2]=o[2],u}function xn(n,o){const t=o??D.create(),e=n[0],u=n[1],p=n[2],m=n[4],s=n[5],i=n[6],h=n[8],w=n[9],x=n[10];return t[0]=Math.sqrt(e*e+u*u+p*p),t[1]=Math.sqrt(m*m+s*s+i*i),t[2]=Math.sqrt(h*h+w*w+x*x),t}function Vn(n,o,t,e,u){const p=u??new a(16),m=Math.tan(Math.PI*.5-.5*n);if(p[0]=m/o,p[1]=0,p[2]=0,p[3]=0,p[4]=0,p[5]=m,p[6]=0,p[7]=0,p[8]=0,p[9]=0,p[11]=-1,p[12]=0,p[13]=0,p[15]=0,Number.isFinite(e)){const s=1/(t-e);p[10]=e*s,p[14]=e*t*s}else p[10]=-1,p[14]=-t;return p}function yn(n,o,t,e=1/0,u){const p=u??new a(16),m=1/Math.tan(n*.5);if(p[0]=m/o,p[1]=0,p[2]=0,p[3]=0,p[4]=0,p[5]=m,p[6]=0,p[7]=0,p[8]=0,p[9]=0,p[11]=-1,p[12]=0,p[13]=0,p[15]=0,e===1/0)p[10]=0,p[14]=t;else{const s=1/(e-t);p[10]=t*s,p[14]=e*t*s}return p}function mn(n,o,t,e,u,p,m){const s=m??new a(16);return s[0]=2/(o-n),s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=2/(e-t),s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=1/(u-p),s[11]=0,s[12]=(o+n)/(n-o),s[13]=(e+t)/(t-e),s[14]=u/(u-p),s[15]=1,s}function nn(n,o,t,e,u,p,m){const s=m??new a(16),i=o-n,h=e-t,w=u-p;return s[0]=2*u/i,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=2*u/h,s[6]=0,s[7]=0,s[8]=(n+o)/i,s[9]=(e+t)/h,s[10]=p/w,s[11]=-1,s[12]=0,s[13]=0,s[14]=u*p/w,s[15]=0,s}function Bn(n,o,t,e,u,p=1/0,m){const s=m??new a(16),i=o-n,h=e-t;if(s[0]=2*u/i,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=2*u/h,s[6]=0,s[7]=0,s[8]=(n+o)/i,s[9]=(e+t)/h,s[11]=-1,s[12]=0,s[13]=0,s[15]=0,p===1/0)s[10]=0,s[14]=u;else{const w=1/(p-u);s[10]=u*w,s[14]=p*u*w}return s}const j=D.create(),Z=D.create(),k=D.create();function f(n,o,t,e){const u=e??new a(16);return D.normalize(D.subtract(o,n,k),k),D.normalize(D.cross(t,k,j),j),D.normalize(D.cross(k,j,Z),Z),u[0]=j[0],u[1]=j[1],u[2]=j[2],u[3]=0,u[4]=Z[0],u[5]=Z[1],u[6]=Z[2],u[7]=0,u[8]=k[0],u[9]=k[1],u[10]=k[2],u[11]=0,u[12]=n[0],u[13]=n[1],u[14]=n[2],u[15]=1,u}function S(n,o,t,e){const u=e??new a(16);return D.normalize(D.subtract(n,o,k),k),D.normalize(D.cross(t,k,j),j),D.normalize(D.cross(k,j,Z),Z),u[0]=j[0],u[1]=j[1],u[2]=j[2],u[3]=0,u[4]=Z[0],u[5]=Z[1],u[6]=Z[2],u[7]=0,u[8]=k[0],u[9]=k[1],u[10]=k[2],u[11]=0,u[12]=n[0],u[13]=n[1],u[14]=n[2],u[15]=1,u}function M(n,o,t,e){const u=e??new a(16);return D.normalize(D.subtract(n,o,k),k),D.normalize(D.cross(t,k,j),j),D.normalize(D.cross(k,j,Z),Z),u[0]=j[0],u[1]=Z[0],u[2]=k[0],u[3]=0,u[4]=j[1],u[5]=Z[1],u[6]=k[1],u[7]=0,u[8]=j[2],u[9]=Z[2],u[10]=k[2],u[11]=0,u[12]=-(j[0]*n[0]+j[1]*n[1]+j[2]*n[2]),u[13]=-(Z[0]*n[0]+Z[1]*n[1]+Z[2]*n[2]),u[14]=-(k[0]*n[0]+k[1]*n[1]+k[2]*n[2]),u[15]=1,u}function v(n,o){const t=o??new a(16);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t}function _(n,o,t){const e=t??new a(16),u=o[0],p=o[1],m=o[2],s=n[0],i=n[1],h=n[2],w=n[3],x=n[1*4+0],y=n[1*4+1],z=n[1*4+2],B=n[1*4+3],G=n[2*4+0],O=n[2*4+1],U=n[2*4+2],Y=n[2*4+3],H=n[3*4+0],Q=n[3*4+1],tn=n[3*4+2],en=n[3*4+3];return n!==e&&(e[0]=s,e[1]=i,e[2]=h,e[3]=w,e[4]=x,e[5]=y,e[6]=z,e[7]=B,e[8]=G,e[9]=O,e[10]=U,e[11]=Y),e[12]=s*u+x*p+G*m+H,e[13]=i*u+y*p+O*m+Q,e[14]=h*u+z*p+U*m+tn,e[15]=w*u+B*p+Y*m+en,e}function P(n,o){const t=o??new a(16),e=Math.cos(n),u=Math.sin(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=u,t[7]=0,t[8]=0,t[9]=-u,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function F(n,o,t){const e=t??new a(16),u=n[4],p=n[5],m=n[6],s=n[7],i=n[8],h=n[9],w=n[10],x=n[11],y=Math.cos(o),z=Math.sin(o);return e[4]=y*u+z*i,e[5]=y*p+z*h,e[6]=y*m+z*w,e[7]=y*s+z*x,e[8]=y*i-z*u,e[9]=y*h-z*p,e[10]=y*w-z*m,e[11]=y*x-z*s,n!==e&&(e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}function E(n,o){const t=o??new a(16),e=Math.cos(n),u=Math.sin(n);return t[0]=e,t[1]=0,t[2]=-u,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=u,t[9]=0,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function I(n,o,t){const e=t??new a(16),u=n[0*4+0],p=n[0*4+1],m=n[0*4+2],s=n[0*4+3],i=n[2*4+0],h=n[2*4+1],w=n[2*4+2],x=n[2*4+3],y=Math.cos(o),z=Math.sin(o);return e[0]=y*u-z*i,e[1]=y*p-z*h,e[2]=y*m-z*w,e[3]=y*s-z*x,e[8]=y*i+z*u,e[9]=y*h+z*p,e[10]=y*w+z*m,e[11]=y*x+z*s,n!==e&&(e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}function q(n,o){const t=o??new a(16),e=Math.cos(n),u=Math.sin(n);return t[0]=e,t[1]=u,t[2]=0,t[3]=0,t[4]=-u,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function L(n,o,t){const e=t??new a(16),u=n[0*4+0],p=n[0*4+1],m=n[0*4+2],s=n[0*4+3],i=n[1*4+0],h=n[1*4+1],w=n[1*4+2],x=n[1*4+3],y=Math.cos(o),z=Math.sin(o);return e[0]=y*u+z*i,e[1]=y*p+z*h,e[2]=y*m+z*w,e[3]=y*s+z*x,e[4]=y*i-z*u,e[5]=y*h-z*p,e[6]=y*w-z*m,e[7]=y*x-z*s,n!==e&&(e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}function $(n,o,t){const e=t??new a(16);let u=n[0],p=n[1],m=n[2];const s=Math.sqrt(u*u+p*p+m*m);u/=s,p/=s,m/=s;const i=u*u,h=p*p,w=m*m,x=Math.cos(o),y=Math.sin(o),z=1-x;return e[0]=i+(1-i)*x,e[1]=u*p*z+m*y,e[2]=u*m*z-p*y,e[3]=0,e[4]=u*p*z-m*y,e[5]=h+(1-h)*x,e[6]=p*m*z+u*y,e[7]=0,e[8]=u*m*z+p*y,e[9]=p*m*z-u*y,e[10]=w+(1-w)*x,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}const g=$;function A(n,o,t,e){const u=e??new a(16);let p=o[0],m=o[1],s=o[2];const i=Math.sqrt(p*p+m*m+s*s);p/=i,m/=i,s/=i;const h=p*p,w=m*m,x=s*s,y=Math.cos(t),z=Math.sin(t),B=1-y,G=h+(1-h)*y,O=p*m*B+s*z,U=p*s*B-m*z,Y=p*m*B-s*z,H=w+(1-w)*y,Q=m*s*B+p*z,tn=p*s*B+m*z,en=m*s*B-p*z,an=x+(1-x)*y,ln=n[0],hn=n[1],wn=n[2],dn=n[3],pn=n[4],vn=n[5],zn=n[6],An=n[7],Sn=n[8],In=n[9],Ln=n[10],En=n[11];return u[0]=G*ln+O*pn+U*Sn,u[1]=G*hn+O*vn+U*In,u[2]=G*wn+O*zn+U*Ln,u[3]=G*dn+O*An+U*En,u[4]=Y*ln+H*pn+Q*Sn,u[5]=Y*hn+H*vn+Q*In,u[6]=Y*wn+H*zn+Q*Ln,u[7]=Y*dn+H*An+Q*En,u[8]=tn*ln+en*pn+an*Sn,u[9]=tn*hn+en*vn+an*In,u[10]=tn*wn+en*zn+an*Ln,u[11]=tn*dn+en*An+an*En,n!==u&&(u[12]=n[12],u[13]=n[13],u[14]=n[14],u[15]=n[15]),u}const c=A;function r(n,o){const t=o??new a(16);return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function l(n,o,t){const e=t??new a(16),u=o[0],p=o[1],m=o[2];return e[0]=u*n[0*4+0],e[1]=u*n[0*4+1],e[2]=u*n[0*4+2],e[3]=u*n[0*4+3],e[4]=p*n[1*4+0],e[5]=p*n[1*4+1],e[6]=p*n[1*4+2],e[7]=p*n[1*4+3],e[8]=m*n[2*4+0],e[9]=m*n[2*4+1],e[10]=m*n[2*4+2],e[11]=m*n[2*4+3],n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}function d(n,o){const t=o??new a(16);return t[0]=n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function T(n,o,t){const e=t??new a(16);return e[0]=o*n[0*4+0],e[1]=o*n[0*4+1],e[2]=o*n[0*4+2],e[3]=o*n[0*4+3],e[4]=o*n[1*4+0],e[5]=o*n[1*4+1],e[6]=o*n[1*4+2],e[7]=o*n[1*4+3],e[8]=o*n[2*4+0],e[9]=o*n[2*4+1],e[10]=o*n[2*4+2],e[11]=o*n[2*4+3],n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}return{create:V,set:R,fromMat3:K,fromQuat:X,negate:b,copy:on,clone:Mn,equalsApproximately:Tn,equals:Pn,identity:cn,transpose:_n,inverse:rn,determinant:qn,invert:un,multiply:J,mul:On,setTranslation:fn,getTranslation:C,getAxis:Un,setAxis:Dn,getScaling:xn,perspective:Vn,perspectiveReverseZ:yn,ortho:mn,frustum:nn,frustumReverseZ:Bn,aim:f,cameraAim:S,lookAt:M,translation:v,translate:_,rotationX:P,rotateX:F,rotationY:E,rotateY:I,rotationZ:q,rotateZ:L,axisRotation:$,rotation:g,axisRotate:A,rotate:c,scaling:r,scale:l,uniformScaling:d,uniformScale:T}}const ft=new Map;function Bt(a){let D=ft.get(a);return D||(D=Ut(a),ft.set(a,D)),D}function It(a){const D=Cn(a);function V(g,A,c,r){const l=new a(4);return g!==void 0&&(l[0]=g,A!==void 0&&(l[1]=A,c!==void 0&&(l[2]=c,r!==void 0&&(l[3]=r)))),l}const R=V;function K(g,A,c,r,l){const d=l??new a(4);return d[0]=g,d[1]=A,d[2]=c,d[3]=r,d}function X(g,A,c){const r=c??new a(4),l=A*.5,d=Math.sin(l);return r[0]=d*g[0],r[1]=d*g[1],r[2]=d*g[2],r[3]=Math.cos(l),r}function b(g,A){const c=A??D.create(3),r=Math.acos(g[3])*2,l=Math.sin(r*.5);return l>N?(c[0]=g[0]/l,c[1]=g[1]/l,c[2]=g[2]/l):(c[0]=1,c[1]=0,c[2]=0),{angle:r,axis:c}}function on(g,A){const c=nn(g,A);return Math.acos(2*c*c-1)}function Mn(g,A,c){const r=c??new a(4),l=g[0],d=g[1],T=g[2],n=g[3],o=A[0],t=A[1],e=A[2],u=A[3];return r[0]=l*u+n*o+d*e-T*t,r[1]=d*u+n*t+T*o-l*e,r[2]=T*u+n*e+l*t-d*o,r[3]=n*u-l*o-d*t-T*e,r}const Tn=Mn;function Pn(g,A,c){const r=c??new a(4),l=A*.5,d=g[0],T=g[1],n=g[2],o=g[3],t=Math.sin(l),e=Math.cos(l);return r[0]=d*e+o*t,r[1]=T*e+n*t,r[2]=n*e-T*t,r[3]=o*e-d*t,r}function cn(g,A,c){const r=c??new a(4),l=A*.5,d=g[0],T=g[1],n=g[2],o=g[3],t=Math.sin(l),e=Math.cos(l);return r[0]=d*e-n*t,r[1]=T*e+o*t,r[2]=n*e+d*t,r[3]=o*e-T*t,r}function _n(g,A,c){const r=c??new a(4),l=A*.5,d=g[0],T=g[1],n=g[2],o=g[3],t=Math.sin(l),e=Math.cos(l);return r[0]=d*e+T*t,r[1]=T*e-d*t,r[2]=n*e+o*t,r[3]=o*e-n*t,r}function rn(g,A,c,r){const l=r??new a(4),d=g[0],T=g[1],n=g[2],o=g[3];let t=A[0],e=A[1],u=A[2],p=A[3],m=d*t+T*e+n*u+o*p;m<0&&(m=-m,t=-t,e=-e,u=-u,p=-p);let s,i;if(1-m>N){const h=Math.acos(m),w=Math.sin(h);s=Math.sin((1-c)*h)/w,i=Math.sin(c*h)/w}else s=1-c,i=c;return l[0]=s*d+i*t,l[1]=s*T+i*e,l[2]=s*n+i*u,l[3]=s*o+i*p,l}function qn(g,A){const c=A??new a(4),r=g[0],l=g[1],d=g[2],T=g[3],n=r*r+l*l+d*d+T*T,o=n?1/n:0;return c[0]=-r*o,c[1]=-l*o,c[2]=-d*o,c[3]=T*o,c}function un(g,A){const c=A??new a(4);return c[0]=-g[0],c[1]=-g[1],c[2]=-g[2],c[3]=g[3],c}function J(g,A){const c=A??new a(4),r=g[0]+g[5]+g[10];if(r>0){const l=Math.sqrt(r+1);c[3]=.5*l;const d=.5/l;c[0]=(g[6]-g[9])*d,c[1]=(g[8]-g[2])*d,c[2]=(g[1]-g[4])*d}else{let l=0;g[5]>g[0]&&(l=1),g[10]>g[l*4+l]&&(l=2);const d=(l+1)%3,T=(l+2)%3,n=Math.sqrt(g[l*4+l]-g[d*4+d]-g[T*4+T]+1);c[l]=.5*n;const o=.5/n;c[3]=(g[d*4+T]-g[T*4+d])*o,c[d]=(g[d*4+l]+g[l*4+d])*o,c[T]=(g[T*4+l]+g[l*4+T])*o}return c}function On(g,A,c,r,l){const d=l??new a(4),T=g*.5,n=A*.5,o=c*.5,t=Math.sin(T),e=Math.cos(T),u=Math.sin(n),p=Math.cos(n),m=Math.sin(o),s=Math.cos(o);switch(r){case"xyz":d[0]=t*p*s+e*u*m,d[1]=e*u*s-t*p*m,d[2]=e*p*m+t*u*s,d[3]=e*p*s-t*u*m;break;case"xzy":d[0]=t*p*s-e*u*m,d[1]=e*u*s-t*p*m,d[2]=e*p*m+t*u*s,d[3]=e*p*s+t*u*m;break;case"yxz":d[0]=t*p*s+e*u*m,d[1]=e*u*s-t*p*m,d[2]=e*p*m-t*u*s,d[3]=e*p*s+t*u*m;break;case"yzx":d[0]=t*p*s+e*u*m,d[1]=e*u*s+t*p*m,d[2]=e*p*m-t*u*s,d[3]=e*p*s-t*u*m;break;case"zxy":d[0]=t*p*s-e*u*m,d[1]=e*u*s+t*p*m,d[2]=e*p*m+t*u*s,d[3]=e*p*s-t*u*m;break;case"zyx":d[0]=t*p*s-e*u*m,d[1]=e*u*s+t*p*m,d[2]=e*p*m-t*u*s,d[3]=e*p*s+t*u*m;break;default:throw new Error(`Unknown rotation order: ${r}`)}return d}function fn(g,A){const c=A??new a(4);return c[0]=g[0],c[1]=g[1],c[2]=g[2],c[3]=g[3],c}const C=fn;function Un(g,A,c){const r=c??new a(4);return r[0]=g[0]+A[0],r[1]=g[1]+A[1],r[2]=g[2]+A[2],r[3]=g[3]+A[3],r}function Dn(g,A,c){const r=c??new a(4);return r[0]=g[0]-A[0],r[1]=g[1]-A[1],r[2]=g[2]-A[2],r[3]=g[3]-A[3],r}const xn=Dn;function Vn(g,A,c){const r=c??new a(4);return r[0]=g[0]*A,r[1]=g[1]*A,r[2]=g[2]*A,r[3]=g[3]*A,r}const yn=Vn;function mn(g,A,c){const r=c??new a(4);return r[0]=g[0]/A,r[1]=g[1]/A,r[2]=g[2]/A,r[3]=g[3]/A,r}function nn(g,A){return g[0]*A[0]+g[1]*A[1]+g[2]*A[2]+g[3]*A[3]}function Bn(g,A,c,r){const l=r??new a(4);return l[0]=g[0]+c*(A[0]-g[0]),l[1]=g[1]+c*(A[1]-g[1]),l[2]=g[2]+c*(A[2]-g[2]),l[3]=g[3]+c*(A[3]-g[3]),l}function j(g){const A=g[0],c=g[1],r=g[2],l=g[3];return Math.sqrt(A*A+c*c+r*r+l*l)}const Z=j;function k(g){const A=g[0],c=g[1],r=g[2],l=g[3];return A*A+c*c+r*r+l*l}const f=k;function S(g,A){const c=A??new a(4),r=g[0],l=g[1],d=g[2],T=g[3],n=Math.sqrt(r*r+l*l+d*d+T*T);return n>1e-5?(c[0]=r/n,c[1]=l/n,c[2]=d/n,c[3]=T/n):(c[0]=0,c[1]=0,c[2]=0,c[3]=1),c}function M(g,A){return Math.abs(g[0]-A[0])<N&&Math.abs(g[1]-A[1])<N&&Math.abs(g[2]-A[2])<N&&Math.abs(g[3]-A[3])<N}function v(g,A){return g[0]===A[0]&&g[1]===A[1]&&g[2]===A[2]&&g[3]===A[3]}function _(g){const A=g??new a(4);return A[0]=0,A[1]=0,A[2]=0,A[3]=1,A}const P=D.create(),F=D.create(),E=D.create();function I(g,A,c){const r=c??new a(4),l=D.dot(g,A);return l<-.999999?(D.cross(F,g,P),D.len(P)<1e-6&&D.cross(E,g,P),D.normalize(P,P),X(P,Math.PI,r),r):l>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(D.cross(g,A,P),r[0]=P[0],r[1]=P[1],r[2]=P[2],r[3]=1+l,S(r,r))}const q=new a(4),L=new a(4);function $(g,A,c,r,l,d){const T=d??new a(4);return rn(g,r,l,q),rn(A,c,l,L),rn(q,L,2*l*(1-l),T),T}return{create:V,fromValues:R,set:K,fromAxisAngle:X,toAxisAngle:b,angle:on,multiply:Mn,mul:Tn,rotateX:Pn,rotateY:cn,rotateZ:_n,slerp:rn,inverse:qn,conjugate:un,fromMat:J,fromEuler:On,copy:fn,clone:C,add:Un,subtract:Dn,sub:xn,mulScalar:Vn,scale:yn,divScalar:mn,dot:nn,lerp:Bn,length:j,len:Z,lengthSq:k,lenSq:f,normalize:S,equalsApproximately:M,equals:v,identity:_,rotationTo:I,sqlerp:$}}const lt=new Map;function Lt(a){let D=lt.get(a);return D||(D=It(a),lt.set(a,D)),D}function Et(a){function D(c,r,l,d){const T=new a(4);return c!==void 0&&(T[0]=c,r!==void 0&&(T[1]=r,l!==void 0&&(T[2]=l,d!==void 0&&(T[3]=d)))),T}const V=D;function R(c,r,l,d,T){const n=T??new a(4);return n[0]=c,n[1]=r,n[2]=l,n[3]=d,n}function K(c,r){const l=r??new a(4);return l[0]=Math.ceil(c[0]),l[1]=Math.ceil(c[1]),l[2]=Math.ceil(c[2]),l[3]=Math.ceil(c[3]),l}function X(c,r){const l=r??new a(4);return l[0]=Math.floor(c[0]),l[1]=Math.floor(c[1]),l[2]=Math.floor(c[2]),l[3]=Math.floor(c[3]),l}function b(c,r){const l=r??new a(4);return l[0]=Math.round(c[0]),l[1]=Math.round(c[1]),l[2]=Math.round(c[2]),l[3]=Math.round(c[3]),l}function on(c,r=0,l=1,d){const T=d??new a(4);return T[0]=Math.min(l,Math.max(r,c[0])),T[1]=Math.min(l,Math.max(r,c[1])),T[2]=Math.min(l,Math.max(r,c[2])),T[3]=Math.min(l,Math.max(r,c[3])),T}function Mn(c,r,l){const d=l??new a(4);return d[0]=c[0]+r[0],d[1]=c[1]+r[1],d[2]=c[2]+r[2],d[3]=c[3]+r[3],d}function Tn(c,r,l,d){const T=d??new a(4);return T[0]=c[0]+r[0]*l,T[1]=c[1]+r[1]*l,T[2]=c[2]+r[2]*l,T[3]=c[3]+r[3]*l,T}function Pn(c,r,l){const d=l??new a(4);return d[0]=c[0]-r[0],d[1]=c[1]-r[1],d[2]=c[2]-r[2],d[3]=c[3]-r[3],d}const cn=Pn;function _n(c,r){return Math.abs(c[0]-r[0])<N&&Math.abs(c[1]-r[1])<N&&Math.abs(c[2]-r[2])<N&&Math.abs(c[3]-r[3])<N}function rn(c,r){return c[0]===r[0]&&c[1]===r[1]&&c[2]===r[2]&&c[3]===r[3]}function qn(c,r,l,d){const T=d??new a(4);return T[0]=c[0]+l*(r[0]-c[0]),T[1]=c[1]+l*(r[1]-c[1]),T[2]=c[2]+l*(r[2]-c[2]),T[3]=c[3]+l*(r[3]-c[3]),T}function un(c,r,l,d){const T=d??new a(4);return T[0]=c[0]+l[0]*(r[0]-c[0]),T[1]=c[1]+l[1]*(r[1]-c[1]),T[2]=c[2]+l[2]*(r[2]-c[2]),T[3]=c[3]+l[3]*(r[3]-c[3]),T}function J(c,r,l){const d=l??new a(4);return d[0]=Math.max(c[0],r[0]),d[1]=Math.max(c[1],r[1]),d[2]=Math.max(c[2],r[2]),d[3]=Math.max(c[3],r[3]),d}function On(c,r,l){const d=l??new a(4);return d[0]=Math.min(c[0],r[0]),d[1]=Math.min(c[1],r[1]),d[2]=Math.min(c[2],r[2]),d[3]=Math.min(c[3],r[3]),d}function fn(c,r,l){const d=l??new a(4);return d[0]=c[0]*r,d[1]=c[1]*r,d[2]=c[2]*r,d[3]=c[3]*r,d}const C=fn;function Un(c,r,l){const d=l??new a(4);return d[0]=c[0]/r,d[1]=c[1]/r,d[2]=c[2]/r,d[3]=c[3]/r,d}function Dn(c,r){const l=r??new a(4);return l[0]=1/c[0],l[1]=1/c[1],l[2]=1/c[2],l[3]=1/c[3],l}const xn=Dn;function Vn(c,r){return c[0]*r[0]+c[1]*r[1]+c[2]*r[2]+c[3]*r[3]}function yn(c){const r=c[0],l=c[1],d=c[2],T=c[3];return Math.sqrt(r*r+l*l+d*d+T*T)}const mn=yn;function nn(c){const r=c[0],l=c[1],d=c[2],T=c[3];return r*r+l*l+d*d+T*T}const Bn=nn;function j(c,r){const l=c[0]-r[0],d=c[1]-r[1],T=c[2]-r[2],n=c[3]-r[3];return Math.sqrt(l*l+d*d+T*T+n*n)}const Z=j;function k(c,r){const l=c[0]-r[0],d=c[1]-r[1],T=c[2]-r[2],n=c[3]-r[3];return l*l+d*d+T*T+n*n}const f=k;function S(c,r){const l=r??new a(4),d=c[0],T=c[1],n=c[2],o=c[3],t=Math.sqrt(d*d+T*T+n*n+o*o);return t>1e-5?(l[0]=d/t,l[1]=T/t,l[2]=n/t,l[3]=o/t):(l[0]=0,l[1]=0,l[2]=0,l[3]=0),l}function M(c,r){const l=r??new a(4);return l[0]=-c[0],l[1]=-c[1],l[2]=-c[2],l[3]=-c[3],l}function v(c,r){const l=r??new a(4);return l[0]=c[0],l[1]=c[1],l[2]=c[2],l[3]=c[3],l}const _=v;function P(c,r,l){const d=l??new a(4);return d[0]=c[0]*r[0],d[1]=c[1]*r[1],d[2]=c[2]*r[2],d[3]=c[3]*r[3],d}const F=P;function E(c,r,l){const d=l??new a(4);return d[0]=c[0]/r[0],d[1]=c[1]/r[1],d[2]=c[2]/r[2],d[3]=c[3]/r[3],d}const I=E;function q(c){const r=c??new a(4);return r[0]=0,r[1]=0,r[2]=0,r[3]=0,r}function L(c,r,l){const d=l??new a(4),T=c[0],n=c[1],o=c[2],t=c[3];return d[0]=r[0]*T+r[4]*n+r[8]*o+r[12]*t,d[1]=r[1]*T+r[5]*n+r[9]*o+r[13]*t,d[2]=r[2]*T+r[6]*n+r[10]*o+r[14]*t,d[3]=r[3]*T+r[7]*n+r[11]*o+r[15]*t,d}function $(c,r,l){const d=l??new a(4);return S(c,d),fn(d,r,d)}function g(c,r,l){const d=l??new a(4);return yn(c)>r?$(c,r,d):v(c,d)}function A(c,r,l){const d=l??new a(4);return qn(c,r,.5,d)}return{create:D,fromValues:V,set:R,ceil:K,floor:X,round:b,clamp:on,add:Mn,addScaled:Tn,subtract:Pn,sub:cn,equalsApproximately:_n,equals:rn,lerp:qn,lerpV:un,max:J,min:On,mulScalar:fn,scale:C,divScalar:Un,inverse:Dn,invert:xn,dot:Vn,length:yn,len:mn,lengthSq:nn,lenSq:Bn,distance:j,dist:Z,distanceSq:k,distSq:f,normalize:S,negate:M,copy:v,clone:_,multiply:P,mul:F,divide:E,div:I,zero:q,transformMat4:L,setLength:$,truncate:g,midpoint:A}}const ht=new Map;function Ft(a){let D=ht.get(a);return D||(D=Et(a),ht.set(a,D)),D}function nt(a,D,V,R,K,X){return{mat4:Bt(a),mat3:Ot(D),quat:Lt(V),vec2:gt(R),vec3:Cn(K),vec4:Ft(X)}}const{mat4:Kn,vec2:Gt,vec3:Fn,vec4:sn}=nt(Float32Array,Float32Array,Float32Array,Float32Array,Float32Array,Float32Array);nt(Float64Array,Float64Array,Float64Array,Float64Array,Float64Array,Float64Array);nt(mt,Array,Array,Array,Array,Array);const Nt=`struct Uniforms {
  projectionMatrix : mat4x4f,
  modelViewMatrix : mat4x4f,
  fogColor : vec4f,
  lightDirection : vec4f,
  cameraPosition: vec4f,
  config : vec4f,
}
@group(0) @binding(0)  var<uniform> uniforms : Uniforms;
@group(1) @binding(0) var grassSampler : sampler;
@group(1) @binding(1) var grassTex : texture_2d<f32>;
@group(1) @binding(2) var mudSampler : sampler;
@group(1) @binding(3) var mudTex : texture_2d<f32>;
@group(1) @binding(4) var rockSampler : sampler;
@group(1) @binding(5) var rockTex : texture_2d<f32>;

struct VertexOut {
  @builtin(position) position : vec4f,
  @location(1) normal : vec3f,
  @location(2) height : f32,
  @location(3) fogDepth : f32,
  @location(4) uv : vec2f,
}

const normalOffsetDelta = 0.032;

const terrainFractalLayers = 5;
const terrainAmplitudeFreq = 0.3;

const uLightDiffuse = vec4f(1.0, 1.0, 1.0, 1.0);

// Phong Light Model
// https://github.com/PacktPublishing/Real-Time-3D-Graphics-with-WebGL-2/blob/master/ch03/ch03_04_sphere-phong.html
fn light(normal: vec3f, materialDiffuse: vec4f, vertex: vec3f) -> vec4f {
  // Normalized light direction
  let L = normalize(uniforms.lightDirection.xyz);

  // Normalized normal
  let N = normalize(normal);

  let lambertTerm = dot(N, -L);
  if (lambertTerm > 0.0) {
    var Id = vec4f(uLightDiffuse * materialDiffuse * lambertTerm);
    return vec4f(Id.xyz, 1.0);
  } else {
    return vec4f(0.0, 0.0, 0.0, 1.0);
  }
}

fn randomGradient(p: vec2f, seed: f32) -> vec2f {
  let x = dot(p, vec2(123.4, 234.5));
  let y = dot(p, vec2(234.5, 345.6));
  var gradient = vec2(x, y);
  gradient = sin(gradient);
  gradient = gradient * 43758.5453 + seed;

  gradient = sin(gradient);
  return gradient;
}

fn quintic(p: vec2f) -> vec2f {
  return p * p * p * (10.0 + p * (-15.0 + p * 6.0));
}

// Perlin Noise
// https://github.com/SuboptimalEng/shader-tutorials/blob/main/05-perlin-noise/shader.frag
fn perlin(p: vec2f, seed: f32) -> f32 {
  // set up a grid of cells
  let gridId = floor(p);
  var gridUv = fract(p);

  // start by finding the coords of grid corners
  let bl = gridId + vec2f(0.0, 0.0);
  let br = gridId + vec2f(1.0, 0.0);
  let tl = gridId + vec2f(0.0, 1.0);
  let tr = gridId + vec2f(1.0, 1.0);

  // find random gradient for each grid corner
  let gradBl = randomGradient(bl, seed);
  let gradBr = randomGradient(br, seed);
  let gradTl = randomGradient(tl, seed);
  let gradTr = randomGradient(tr, seed);

  // find distance from current pixel to each grid corner
  let distFromPixelToBl = gridUv - vec2f(0.0, 0.0);
  let distFromPixelToBr = gridUv - vec2f(1.0, 0.0);
  let distFromPixelToTl = gridUv - vec2f(0.0, 1.0);
  let distFromPixelToTr = gridUv - vec2f(1.0, 1.0);

  // calculate the dot products of gradients + distances
  let dotBl = dot(gradBl, distFromPixelToBl);
  let dotBr = dot(gradBr, distFromPixelToBr);
  let dotTl = dot(gradTl, distFromPixelToTl);
  let dotTr = dot(gradTr, distFromPixelToTr);

  // smooth out gridUvs
  gridUv = quintic(gridUv);

  // perform linear interpolation between 4 dot products
  let b = mix(dotBl, dotBr, gridUv.x);
  let t = mix(dotTl, dotTr, gridUv.x);
  return mix(b, t, gridUv.y) / 2.0 + 0.5;
}

// Fractal Perlin Noise
fn terrainHeight(p: vec2f) -> f32 {
  let animationState = uniforms.config.w;
  var fractal = 0.0;
  fractal += perlin(p / 6, animationState) * 2.50;
  fractal += perlin(p,     animationState) * 0.80;
  fractal += perlin(p * 2, animationState) * 0.20;
  fractal += perlin(p * 4, animationState) * 0.10;
  fractal += perlin(p * 8, animationState) * 0.04;
  return fractal;
}

// Generate normal from perlin noise using derivatives
// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/perlin-noise-part-2/perlin-noise-computing-derivatives.html
fn terrainNormal(position: vec2f, noise_value: f32) -> vec3f {
  // point a bit to the right of the original value
  let position_offset_x = position.xy + vec2f(normalOffsetDelta, 0.0);
  // what is its noise value
  let noise_offset_x = terrainHeight(position_offset_x);
  // a vector from the point to the other one, using the noise result
  // as the third dimension
  let tangent_x = normalize(vec3f(position.xy, noise_value) - vec3f(position_offset_x, noise_offset_x));

  // same for Y
  let position_offset_y = position.xy + vec2f(0.0, normalOffsetDelta);
  let noise_offset_y = terrainHeight(position_offset_y);
  let tangent_y = normalize(vec3f(position.xy, noise_value) - vec3f(position_offset_y, noise_offset_y));

  // cross product of the two tangents of the point will create
  // the normal vector at that point
  return cross(tangent_x, tangent_y);
}

@vertex
fn vertex_main(@location(0) position: vec4f) -> VertexOut {
  let time = uniforms.config.x;

  // Offset the position by the actual camera position to simulate the camera moving
  let offset_position = position.xz + uniforms.cameraPosition.xz;
  var terrain_value = terrainHeight(offset_position);

  var normal = vec3f(0.0, 1.0, 0.0);
  normal = terrainNormal(offset_position, terrain_value);
  let terrain_position = vec4f(position.x, terrain_value, position.z, 1.0);

  var output = VertexOut();
  output.position = uniforms.projectionMatrix * uniforms.modelViewMatrix * terrain_position;
  output.height = terrain_value;
  output.uv = offset_position;
  output.normal = normal;
  // Fog depth is the distance from the camera to the vertex
  // https://webglfundamentals.org/webgl/lessons/webgl-fog.html
  output.fogDepth = -(uniforms.modelViewMatrix * terrain_position).z;
  return output;
}

@fragment
fn fragment_main(fragData: VertexOut) -> @location(0) vec4f {
  let fogOn = uniforms.config.y == 1.0;
  let lightsOn = uniforms.config.z == 1.0;

  let steepness = 1.0 - abs(dot(fragData.normal, vec3f(0.0, 1.0, 0.0)));
  let uv = abs(fragData.uv % 1.0);

  // Use steepness to mix between grass and mud textures
  var color = mix(
    textureSample(mudTex, mudSampler, uv),
    textureSample(grassTex, grassSampler, uv),
    smoothstep(0.3, 1.0, steepness)
  );
  // Use height to mix in rock texture on the peaks
  color = mix(
    color,
    textureSample(rockTex, rockSampler, uv),
    smoothstep(1.7, 2.3, fragData.height)
  );
  // Apply lighting if enabled
  color = select(color, light(fragData.normal, color, fragData.position.xyz), lightsOn);
  if (!fogOn) {
    return color;
  } else {
    let fogAmount = smoothstep(2.0, 8.0, fragData.fogDepth);
    return mix(color, vec4f(0.8, 0.9, 1.0, 1.0), fogAmount);  
  }
}`;class Rt{constructor(D,V=new Float32Array([0,1,0])){W(this,"viewMatrix");W(this,"position");W(this,"front",Fn.fromValues());W(this,"up",Fn.fromValues());W(this,"worldUp",Fn.fromValues());W(this,"right",Fn.fromValues());W(this,"yaw",-90);W(this,"pitch",-30);this.position=D,this.worldUp=V,this.viewMatrix=Kn.identity(),this.updateCameraVectors()}updateCameraVectors(){this.front=Fn.normalize(Fn.fromValues(Math.cos(kn.degToRad(this.yaw))*Math.cos(kn.degToRad(this.pitch)),Math.sin(kn.degToRad(this.pitch)),Math.sin(kn.degToRad(this.yaw))*Math.cos(kn.degToRad(this.pitch)))),this.right=Fn.normalize(Fn.cross(this.front,this.worldUp)),this.up=Fn.normalize(Fn.cross(this.right,this.front))}processControls(D,V){const R=V;D.forwardKey&&(this.position=sn.add(this.position,sn.mul(this.front,sn.fromValues(R,R,R)))),D.backwardKey&&(this.position=sn.sub(this.position,sn.mul(this.front,sn.fromValues(R,R,R)))),D.leftKey&&(this.position=sn.sub(this.position,sn.mul(this.right,sn.fromValues(R,R,R)))),D.rightKey&&(this.position=sn.add(this.position,sn.mul(this.right,sn.fromValues(R,R,R))))}processMouseMovement(D,V){D*=.5,V*=.5,this.yaw+=D,this.pitch+=V,this.pitch>89?this.pitch=89:this.pitch<-89&&(this.pitch=-89),this.updateCameraVectors()}getViewMatrix(D=new Float32Array([this.position[0],this.position[2]])){const V=Fn.fromValues(D[0],this.position[1],D[2]);return Kn.lookAt(V,Fn.add(V,this.front),this.up)}}var Nn;class kt{constructor(){W(this,"projectionMatrix",Kn.create());W(this,"modelViewMatrix",Kn.create());W(this,"lightDirection",sn.create());W(this,"fogColor",sn.create());W(this,"cameraPosition",sn.create());W(this,"config",sn.create());W(this,"uniformBufferSize",this.projectionMatrix.byteLength+this.modelViewMatrix.byteLength+this.fogColor.byteLength+this.lightDirection.byteLength+this.cameraPosition.byteLength+this.config.byteLength);rt(this,Nn,new Float32Array(this.uniformBufferSize/4));W(this,"getBufferData",()=>{const D=[this.projectionMatrix,this.modelViewMatrix,this.fogColor,this.lightDirection,this.cameraPosition,this.config];let V=0;for(let R=0;R<D.length;R++)Rn(this,Nn).set(D[R],V),V+=D[R].byteLength/4;return{data:Rn(this,Nn).buffer,dataOffset:Rn(this,Nn).byteOffset,size:Rn(this,Nn).byteLength}})}}Nn=new WeakMap;class Kt{constructor(D,V){W(this,"forwardKey",!1);W(this,"backwardKey",!1);W(this,"leftKey",!1);W(this,"rightKey",!1);W(this,"fogOn",!0);W(this,"lightsOn",!0);W(this,"animationOn",!1);document.addEventListener("keydown",K=>{switch(K.key){case"w":this.forwardKey=!0;break;case"s":this.backwardKey=!0;break;case"a":this.leftKey=!0;break;case"d":this.rightKey=!0;break;case"1":this.fogOn=!this.fogOn;break;case"2":this.lightsOn=!this.lightsOn;break;case"3":this.animationOn=!this.animationOn;break}}),document.addEventListener("keyup",K=>{switch(K.key){case"w":this.forwardKey=!1;break;case"s":this.backwardKey=!1;break;case"a":this.leftKey=!1;break;case"d":this.rightKey=!1;break;case"Escape":D.removeEventListener("mousemove",R);break}});const R=K=>{V(K.movementX,-K.movementY)};D.addEventListener("click",()=>{D.requestPointerLock(),D.addEventListener("mousemove",R)})}}const $t=""+new URL("grass-ByvaxTny.png",import.meta.url).href,Yt=""+new URL("mud-Bpq3ZoLx.png",import.meta.url).href,jt=""+new URL("rock-CjqCD_LY.png",import.meta.url).href,Ht=.002,Xt=800,Gn=800,bn=8,wt=1/(Gn-1)*(bn*2),dt=sn.fromValues(.8,.9,1,1),Jn=sn.fromValues(0,3,0),Zt=sn.fromValues(-.25,-.25,-.25,0);let pt=performance.now(),Qn=0;const Wt=async()=>{if(!navigator.gpu)throw Error("WebGPU not supported.");const a=await navigator.gpu.requestAdapter();if(!a)throw Error("Couldn't request WebGPU adapter.");const D=await a.requestDevice(),V=document.querySelector("#gpuCanvas");V.width=window.innerWidth,V.height=window.innerHeight;const R=V.getContext("webgpu"),K=[];for(let _=-8;_<=bn;_=_+wt)for(let P=-8;P<=bn;P=P+wt)K.push(_,0,P);const X=new Float32Array(K),b=[];for(let _=0;_<=Gn-2;_++)for(let P=0;P<=Gn-2;P++){const F=_*Gn+P,E=_*Gn+P+1,I=(_+1)*Gn+P+1,q=(_+1)*Gn+P;b.push(F,E,q),b.push(E,q,I)}const on=new Uint32Array(b),Mn=D.createShaderModule({code:Nt});R.configure({device:D,format:navigator.gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"});const Tn=D.createBuffer({label:"vertex buffer",size:X.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});D.queue.writeBuffer(Tn,0,X,0,X.length);const Pn={attributes:[{shaderLocation:0,offset:0,format:"float32x3"}],arrayStride:12,stepMode:"vertex"},cn=D.createBuffer({label:"index buffer",size:on.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST});D.queue.writeBuffer(cn,0,on);const _n="depth24plus",rn=D.createTexture({label:"depth",size:[V.width,V.height,1],format:_n,usage:GPUTextureUsage.RENDER_ATTACHMENT}),qn={vertex:{module:Mn,entryPoint:"vertex_main",buffers:[Pn]},fragment:{module:Mn,entryPoint:"fragment_main",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]},primitive:{topology:"triangle-list"},depthStencil:{format:_n,depthWriteEnabled:!0,depthCompare:"less-equal"},layout:"auto"},un=D.createRenderPipeline(qn),J=new kt,On=D.createBuffer({label:"uniform buffer",size:J.uniformBufferSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),fn=D.createBindGroup({layout:un.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:On}}]});async function C(_,P){const E=await(await fetch(P)).blob(),I=await createImageBitmap(E,{colorSpaceConversion:"none"}),q=_.createTexture({label:`texture:${P}`,size:{width:I.width,height:I.height},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});_.queue.copyExternalImageToTexture({source:I},{texture:q},{width:I.width,height:I.height});const L=q.createView(),$=_.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"});return{texture:q,view:L,sampler:$,width:I.width,height:I.height}}const{view:Un,sampler:Dn}=await C(D,$t),{view:xn,sampler:Vn}=await C(D,Yt),{view:yn,sampler:mn}=await C(D,jt),nn=D.createBindGroup({layout:un.getBindGroupLayout(1),entries:[{binding:0,resource:Dn},{binding:1,resource:Un},{binding:2,resource:Vn},{binding:3,resource:xn},{binding:4,resource:mn},{binding:5,resource:yn}]}),Bn=V.width/V.height,k=Kn.perspective(2*Math.PI/5,Bn,.1,50),f=new Rt(Jn),S=new Kt(V,(_,P)=>f.processMouseMovement(_,P));function M(_){f.processControls(S,_);const P=Gt.fromValues(Jn[0],Jn[2]);return f.getViewMatrix(P)}function v(){const _=performance.now(),P=_-pt;pt=_;const F=_/Xt%1e3,E=M(P*Ht);J.projectionMatrix=k,J.modelViewMatrix=E,J.fogColor=dt,J.lightDirection=Zt,J.cameraPosition=f.position,Qn=S.animationOn?Qn+P*.001:Qn,J.config=new Float32Array([F,S.fogOn?1:0,S.lightsOn?1:0,Qn]);const I=J.getBufferData();D.queue.writeBuffer(On,0,I.data,I.dataOffset,I.size);const[q,L,$,g]=dt,A={colorAttachments:[{clearValue:{r:q,g:L,b:$,a:g},loadOp:"clear",storeOp:"store",view:R.getCurrentTexture().createView()}],depthStencilAttachment:{view:rn.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},c=D.createCommandEncoder(),r=c.beginRenderPass(A);r.setPipeline(un),r.setBindGroup(0,fn),r.setBindGroup(1,nn),r.setVertexBuffer(0,Tn),r.setIndexBuffer(cn,"uint32"),r.drawIndexed(b.length),r.end(),D.queue.submit([c.finish()]),requestAnimationFrame(()=>v())}v()};Wt();
