var gt=Object.defineProperty;var st=f=>{throw TypeError(f)};var Mt=(f,D,P)=>D in f?gt(f,D,{enumerable:!0,configurable:!0,writable:!0,value:P}):f[D]=P;var b=(f,D,P)=>Mt(f,typeof D!="symbol"?D+"":D,P),Dt=(f,D,P)=>D.has(f)||st("Cannot "+P);var Fn=(f,D,P)=>(Dt(f,D,"read from private field"),P?P.call(f):D.get(f)),ct=(f,D,P)=>D.has(f)?st("Cannot add the same private member more than once"):D instanceof WeakSet?D.add(f):D.set(f,P);(function(){const D=document.createElement("link").relList;if(D&&D.supports&&D.supports("modulepreload"))return;for(const W of document.querySelectorAll('link[rel="modulepreload"]'))B(W);new MutationObserver(W=>{for(const N of W)if(N.type==="childList")for(const C of N.addedNodes)C.tagName==="LINK"&&C.rel==="modulepreload"&&B(C)}).observe(document,{childList:!0,subtree:!0});function P(W){const N={};return W.integrity&&(N.integrity=W.integrity),W.referrerPolicy&&(N.referrerPolicy=W.referrerPolicy),W.crossOrigin==="use-credentials"?N.credentials="include":W.crossOrigin==="anonymous"?N.credentials="omit":N.credentials="same-origin",N}function B(W){if(W.ep)return;W.ep=!0;const N=P(W);fetch(W.href,N)}})();function xt(f,D){return class extends f{constructor(...P){super(...P),D(this)}}}const yt=xt(Array,f=>f.fill(0));let I=1e-6;function _t(f){const D=I;return I=f,D}function vt(f){return f*Math.PI/180}function St(f){return f*180/Math.PI}function zt(f,D,P){return f+(D-f)*P}function Ot(f,D,P){const B=D-f;return Math.abs(D-f)<I?f:(P-f)/B}function At(f,D){return(f%D+D)%D}var Gn={__proto__:null,get EPSILON(){return I},degToRad:vt,euclideanModulo:At,inverseLerp:Ot,lerp:zt,radToDeg:St,setEpsilon:_t};function Tt(f){function D(n=0,s=0){const t=new f(2);return n!==void 0&&(t[0]=n,s!==void 0&&(t[1]=s)),t}const P=D;function B(n,s,t){const e=t??new f(2);return e[0]=n,e[1]=s,e}function W(n,s){const t=s??new f(2);return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t}function N(n,s){const t=s??new f(2);return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t}function C(n,s){const t=s??new f(2);return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t}function tn(n,s=0,t=1,e){const u=e??new f(2);return u[0]=Math.min(t,Math.max(s,n[0])),u[1]=Math.min(t,Math.max(s,n[1])),u}function vn(n,s,t){const e=t??new f(2);return e[0]=n[0]+s[0],e[1]=n[1]+s[1],e}function En(n,s,t,e){const u=e??new f(2);return u[0]=n[0]+s[0]*t,u[1]=n[1]+s[1]*t,u}function Pn(n,s){const t=n[0],e=n[1],u=s[0],p=s[1],_=Math.sqrt(t*t+e*e),o=Math.sqrt(u*u+p*p),i=_*o,w=i&&an(n,s)/i;return Math.acos(w)}function fn(n,s,t){const e=t??new f(2);return e[0]=n[0]-s[0],e[1]=n[1]-s[1],e}const en=fn;function sn(n,s){return Math.abs(n[0]-s[0])<I&&Math.abs(n[1]-s[1])<I}function Rn(n,s){return n[0]===s[0]&&n[1]===s[1]}function hn(n,s,t,e){const u=e??new f(2);return u[0]=n[0]+t*(s[0]-n[0]),u[1]=n[1]+t*(s[1]-n[1]),u}function Sn(n,s,t,e){const u=e??new f(2);return u[0]=n[0]+t[0]*(s[0]-n[0]),u[1]=n[1]+t[1]*(s[1]-n[1]),u}function qn(n,s,t){const e=t??new f(2);return e[0]=Math.max(n[0],s[0]),e[1]=Math.max(n[1],s[1]),e}function dn(n,s,t){const e=t??new f(2);return e[0]=Math.min(n[0],s[0]),e[1]=Math.min(n[1],s[1]),e}function on(n,s,t){const e=t??new f(2);return e[0]=n[0]*s,e[1]=n[1]*s,e}const zn=on;function On(n,s,t){const e=t??new f(2);return e[0]=n[0]/s,e[1]=n[1]/s,e}function pn(n,s){const t=s??new f(2);return t[0]=1/n[0],t[1]=1/n[1],t}const Z=pn;function Q(n,s,t){const e=t??new f(3),u=n[0]*s[1]-n[1]*s[0];return e[0]=0,e[1]=0,e[2]=u,e}function an(n,s){return n[0]*s[0]+n[1]*s[1]}function nn(n){const s=n[0],t=n[1];return Math.sqrt(s*s+t*t)}const ln=nn;function G(n){const s=n[0],t=n[1];return s*s+t*t}const J=G;function K(n,s){const t=n[0]-s[0],e=n[1]-s[1];return Math.sqrt(t*t+e*e)}const a=K;function O(n,s){const t=n[0]-s[0],e=n[1]-s[1];return t*t+e*e}const M=O;function v(n,s){const t=s??new f(2),e=n[0],u=n[1],p=Math.sqrt(e*e+u*u);return p>1e-5?(t[0]=e/p,t[1]=u/p):(t[0]=0,t[1]=0),t}function E(n,s){const t=s??new f(2);return t[0]=-n[0],t[1]=-n[1],t}function T(n,s){const t=s??new f(2);return t[0]=n[0],t[1]=n[1],t}const U=T;function F(n,s,t){const e=t??new f(2);return e[0]=n[0]*s[0],e[1]=n[1]*s[1],e}const j=F;function q(n,s,t){const e=t??new f(2);return e[0]=n[0]/s[0],e[1]=n[1]/s[1],e}const H=q;function X(n=1,s){const t=s??new f(2),e=Math.random()*2*Math.PI;return t[0]=Math.cos(e)*n,t[1]=Math.sin(e)*n,t}function g(n){const s=n??new f(2);return s[0]=0,s[1]=0,s}function z(n,s,t){const e=t??new f(2),u=n[0],p=n[1];return e[0]=u*s[0]+p*s[4]+s[12],e[1]=u*s[1]+p*s[5]+s[13],e}function c(n,s,t){const e=t??new f(2),u=n[0],p=n[1];return e[0]=s[0]*u+s[4]*p+s[8],e[1]=s[1]*u+s[5]*p+s[9],e}function r(n,s,t,e){const u=e??new f(2),p=n[0]-s[0],_=n[1]-s[1],o=Math.sin(t),i=Math.cos(t);return u[0]=p*i-_*o+s[0],u[1]=p*o+_*i+s[1],u}function l(n,s,t){const e=t??new f(2);return v(n,e),on(e,s,e)}function d(n,s,t){const e=t??new f(2);return nn(n)>s?l(n,s,e):T(n,e)}function A(n,s,t){const e=t??new f(2);return hn(n,s,.5,e)}return{create:D,fromValues:P,set:B,ceil:W,floor:N,round:C,clamp:tn,add:vn,addScaled:En,angle:Pn,subtract:fn,sub:en,equalsApproximately:sn,equals:Rn,lerp:hn,lerpV:Sn,max:qn,min:dn,mulScalar:on,scale:zn,divScalar:On,inverse:pn,invert:Z,cross:Q,dot:an,length:nn,len:ln,lengthSq:G,lenSq:J,distance:K,dist:a,distanceSq:O,distSq:M,normalize:v,negate:E,copy:T,clone:U,multiply:F,mul:j,divide:q,div:H,random:X,zero:g,transformMat4:z,transformMat3:c,rotate:r,setLength:l,truncate:d,midpoint:A}}const rt=new Map;function pt(f){let D=rt.get(f);return D||(D=Tt(f),rt.set(f,D)),D}function mt(f){const D=pt(f);function P(a,O,M,v,E,T,U,F,j){const q=new f(12);return q[3]=0,q[7]=0,q[11]=0,a!==void 0&&(q[0]=a,O!==void 0&&(q[1]=O,M!==void 0&&(q[2]=M,v!==void 0&&(q[4]=v,E!==void 0&&(q[5]=E,T!==void 0&&(q[6]=T,U!==void 0&&(q[8]=U,F!==void 0&&(q[9]=F,j!==void 0&&(q[10]=j))))))))),q}function B(a,O,M,v,E,T,U,F,j,q){const H=q??new f(12);return H[0]=a,H[1]=O,H[2]=M,H[3]=0,H[4]=v,H[5]=E,H[6]=T,H[7]=0,H[8]=U,H[9]=F,H[10]=j,H[11]=0,H}function W(a,O){const M=O??new f(12);return M[0]=a[0],M[1]=a[1],M[2]=a[2],M[3]=0,M[4]=a[4],M[5]=a[5],M[6]=a[6],M[7]=0,M[8]=a[8],M[9]=a[9],M[10]=a[10],M[11]=0,M}function N(a,O){const M=O??new f(12),v=a[0],E=a[1],T=a[2],U=a[3],F=v+v,j=E+E,q=T+T,H=v*F,X=E*F,g=E*j,z=T*F,c=T*j,r=T*q,l=U*F,d=U*j,A=U*q;return M[0]=1-g-r,M[1]=X+A,M[2]=z-d,M[3]=0,M[4]=X-A,M[5]=1-H-r,M[6]=c+l,M[7]=0,M[8]=z+d,M[9]=c-l,M[10]=1-H-g,M[11]=0,M}function C(a,O){const M=O??new f(12);return M[0]=-a[0],M[1]=-a[1],M[2]=-a[2],M[4]=-a[4],M[5]=-a[5],M[6]=-a[6],M[8]=-a[8],M[9]=-a[9],M[10]=-a[10],M}function tn(a,O){const M=O??new f(12);return M[0]=a[0],M[1]=a[1],M[2]=a[2],M[4]=a[4],M[5]=a[5],M[6]=a[6],M[8]=a[8],M[9]=a[9],M[10]=a[10],M}const vn=tn;function En(a,O){return Math.abs(a[0]-O[0])<I&&Math.abs(a[1]-O[1])<I&&Math.abs(a[2]-O[2])<I&&Math.abs(a[4]-O[4])<I&&Math.abs(a[5]-O[5])<I&&Math.abs(a[6]-O[6])<I&&Math.abs(a[8]-O[8])<I&&Math.abs(a[9]-O[9])<I&&Math.abs(a[10]-O[10])<I}function Pn(a,O){return a[0]===O[0]&&a[1]===O[1]&&a[2]===O[2]&&a[4]===O[4]&&a[5]===O[5]&&a[6]===O[6]&&a[8]===O[8]&&a[9]===O[9]&&a[10]===O[10]}function fn(a){const O=a??new f(12);return O[0]=1,O[1]=0,O[2]=0,O[4]=0,O[5]=1,O[6]=0,O[8]=0,O[9]=0,O[10]=1,O}function en(a,O){const M=O??new f(12);if(M===a){let g;return g=a[1],a[1]=a[4],a[4]=g,g=a[2],a[2]=a[8],a[8]=g,g=a[6],a[6]=a[9],a[9]=g,M}const v=a[0*4+0],E=a[0*4+1],T=a[0*4+2],U=a[1*4+0],F=a[1*4+1],j=a[1*4+2],q=a[2*4+0],H=a[2*4+1],X=a[2*4+2];return M[0]=v,M[1]=U,M[2]=q,M[4]=E,M[5]=F,M[6]=H,M[8]=T,M[9]=j,M[10]=X,M}function sn(a,O){const M=O??new f(12),v=a[0*4+0],E=a[0*4+1],T=a[0*4+2],U=a[1*4+0],F=a[1*4+1],j=a[1*4+2],q=a[2*4+0],H=a[2*4+1],X=a[2*4+2],g=X*F-j*H,z=-X*U+j*q,c=H*U-F*q,r=1/(v*g+E*z+T*c);return M[0]=g*r,M[1]=(-X*E+T*H)*r,M[2]=(j*E-T*F)*r,M[4]=z*r,M[5]=(X*v-T*q)*r,M[6]=(-j*v+T*U)*r,M[8]=c*r,M[9]=(-H*v+E*q)*r,M[10]=(F*v-E*U)*r,M}function Rn(a){const O=a[0],M=a[0*4+1],v=a[0*4+2],E=a[1*4+0],T=a[1*4+1],U=a[1*4+2],F=a[2*4+0],j=a[2*4+1],q=a[2*4+2];return O*(T*q-j*U)-E*(M*q-j*v)+F*(M*U-T*v)}const hn=sn;function Sn(a,O,M){const v=M??new f(12),E=a[0],T=a[1],U=a[2],F=a[4],j=a[5],q=a[6],H=a[8],X=a[9],g=a[10],z=O[0],c=O[1],r=O[2],l=O[4],d=O[5],A=O[6],n=O[8],s=O[9],t=O[10];return v[0]=E*z+F*c+H*r,v[1]=T*z+j*c+X*r,v[2]=U*z+q*c+g*r,v[4]=E*l+F*d+H*A,v[5]=T*l+j*d+X*A,v[6]=U*l+q*d+g*A,v[8]=E*n+F*s+H*t,v[9]=T*n+j*s+X*t,v[10]=U*n+q*s+g*t,v}const qn=Sn;function dn(a,O,M){const v=M??fn();return a!==v&&(v[0]=a[0],v[1]=a[1],v[2]=a[2],v[4]=a[4],v[5]=a[5],v[6]=a[6]),v[8]=O[0],v[9]=O[1],v[10]=1,v}function on(a,O){const M=O??D.create();return M[0]=a[8],M[1]=a[9],M}function zn(a,O,M){const v=M??D.create(),E=O*4;return v[0]=a[E+0],v[1]=a[E+1],v}function On(a,O,M,v){const E=v===a?a:tn(a,v),T=M*4;return E[T+0]=O[0],E[T+1]=O[1],E}function pn(a,O){const M=O??D.create(),v=a[0],E=a[1],T=a[4],U=a[5];return M[0]=Math.sqrt(v*v+E*E),M[1]=Math.sqrt(T*T+U*U),M}function Z(a,O){const M=O??new f(12);return M[0]=1,M[1]=0,M[2]=0,M[4]=0,M[5]=1,M[6]=0,M[8]=a[0],M[9]=a[1],M[10]=1,M}function Q(a,O,M){const v=M??new f(12),E=O[0],T=O[1],U=a[0],F=a[1],j=a[2],q=a[1*4+0],H=a[1*4+1],X=a[1*4+2],g=a[2*4+0],z=a[2*4+1],c=a[2*4+2];return a!==v&&(v[0]=U,v[1]=F,v[2]=j,v[4]=q,v[5]=H,v[6]=X),v[8]=U*E+q*T+g,v[9]=F*E+H*T+z,v[10]=j*E+X*T+c,v}function an(a,O){const M=O??new f(12),v=Math.cos(a),E=Math.sin(a);return M[0]=v,M[1]=E,M[2]=0,M[4]=-E,M[5]=v,M[6]=0,M[8]=0,M[9]=0,M[10]=1,M}function nn(a,O,M){const v=M??new f(12),E=a[0*4+0],T=a[0*4+1],U=a[0*4+2],F=a[1*4+0],j=a[1*4+1],q=a[1*4+2],H=Math.cos(O),X=Math.sin(O);return v[0]=H*E+X*F,v[1]=H*T+X*j,v[2]=H*U+X*q,v[4]=H*F-X*E,v[5]=H*j-X*T,v[6]=H*q-X*U,a!==v&&(v[8]=a[8],v[9]=a[9],v[10]=a[10]),v}function ln(a,O){const M=O??new f(12);return M[0]=a[0],M[1]=0,M[2]=0,M[4]=0,M[5]=a[1],M[6]=0,M[8]=0,M[9]=0,M[10]=1,M}function G(a,O,M){const v=M??new f(12),E=O[0],T=O[1];return v[0]=E*a[0*4+0],v[1]=E*a[0*4+1],v[2]=E*a[0*4+2],v[4]=T*a[1*4+0],v[5]=T*a[1*4+1],v[6]=T*a[1*4+2],a!==v&&(v[8]=a[8],v[9]=a[9],v[10]=a[10]),v}function J(a,O){const M=O??new f(12);return M[0]=a,M[1]=0,M[2]=0,M[4]=0,M[5]=a,M[6]=0,M[8]=0,M[9]=0,M[10]=1,M}function K(a,O,M){const v=M??new f(12);return v[0]=O*a[0*4+0],v[1]=O*a[0*4+1],v[2]=O*a[0*4+2],v[4]=O*a[1*4+0],v[5]=O*a[1*4+1],v[6]=O*a[1*4+2],a!==v&&(v[8]=a[8],v[9]=a[9],v[10]=a[10]),v}return{clone:vn,create:P,set:B,fromMat4:W,fromQuat:N,negate:C,copy:tn,equalsApproximately:En,equals:Pn,identity:fn,transpose:en,inverse:sn,invert:hn,determinant:Rn,mul:qn,multiply:Sn,setTranslation:dn,getTranslation:on,getAxis:zn,setAxis:On,getScaling:pn,translation:Z,translate:Q,rotation:an,rotate:nn,scaling:ln,scale:G,uniformScaling:J,uniformScale:K}}const it=new Map;function Lt(f){let D=it.get(f);return D||(D=mt(f),it.set(f,D)),D}function Et(f){function D(o,i,w){const h=new f(3);return o!==void 0&&(h[0]=o,i!==void 0&&(h[1]=i,w!==void 0&&(h[2]=w))),h}const P=D;function B(o,i,w,h){const x=h??new f(3);return x[0]=o,x[1]=i,x[2]=w,x}function W(o,i){const w=i??new f(3);return w[0]=Math.ceil(o[0]),w[1]=Math.ceil(o[1]),w[2]=Math.ceil(o[2]),w}function N(o,i){const w=i??new f(3);return w[0]=Math.floor(o[0]),w[1]=Math.floor(o[1]),w[2]=Math.floor(o[2]),w}function C(o,i){const w=i??new f(3);return w[0]=Math.round(o[0]),w[1]=Math.round(o[1]),w[2]=Math.round(o[2]),w}function tn(o,i=0,w=1,h){const x=h??new f(3);return x[0]=Math.min(w,Math.max(i,o[0])),x[1]=Math.min(w,Math.max(i,o[1])),x[2]=Math.min(w,Math.max(i,o[2])),x}function vn(o,i,w){const h=w??new f(3);return h[0]=o[0]+i[0],h[1]=o[1]+i[1],h[2]=o[2]+i[2],h}function En(o,i,w,h){const x=h??new f(3);return x[0]=o[0]+i[0]*w,x[1]=o[1]+i[1]*w,x[2]=o[2]+i[2]*w,x}function Pn(o,i){const w=o[0],h=o[1],x=o[2],y=i[0],S=i[1],R=i[2],V=Math.sqrt(w*w+h*h+x*x),m=Math.sqrt(y*y+S*S+R*R),L=V*m,$=L&&an(o,i)/L;return Math.acos($)}function fn(o,i,w){const h=w??new f(3);return h[0]=o[0]-i[0],h[1]=o[1]-i[1],h[2]=o[2]-i[2],h}const en=fn;function sn(o,i){return Math.abs(o[0]-i[0])<I&&Math.abs(o[1]-i[1])<I&&Math.abs(o[2]-i[2])<I}function Rn(o,i){return o[0]===i[0]&&o[1]===i[1]&&o[2]===i[2]}function hn(o,i,w,h){const x=h??new f(3);return x[0]=o[0]+w*(i[0]-o[0]),x[1]=o[1]+w*(i[1]-o[1]),x[2]=o[2]+w*(i[2]-o[2]),x}function Sn(o,i,w,h){const x=h??new f(3);return x[0]=o[0]+w[0]*(i[0]-o[0]),x[1]=o[1]+w[1]*(i[1]-o[1]),x[2]=o[2]+w[2]*(i[2]-o[2]),x}function qn(o,i,w){const h=w??new f(3);return h[0]=Math.max(o[0],i[0]),h[1]=Math.max(o[1],i[1]),h[2]=Math.max(o[2],i[2]),h}function dn(o,i,w){const h=w??new f(3);return h[0]=Math.min(o[0],i[0]),h[1]=Math.min(o[1],i[1]),h[2]=Math.min(o[2],i[2]),h}function on(o,i,w){const h=w??new f(3);return h[0]=o[0]*i,h[1]=o[1]*i,h[2]=o[2]*i,h}const zn=on;function On(o,i,w){const h=w??new f(3);return h[0]=o[0]/i,h[1]=o[1]/i,h[2]=o[2]/i,h}function pn(o,i){const w=i??new f(3);return w[0]=1/o[0],w[1]=1/o[1],w[2]=1/o[2],w}const Z=pn;function Q(o,i,w){const h=w??new f(3),x=o[2]*i[0]-o[0]*i[2],y=o[0]*i[1]-o[1]*i[0];return h[0]=o[1]*i[2]-o[2]*i[1],h[1]=x,h[2]=y,h}function an(o,i){return o[0]*i[0]+o[1]*i[1]+o[2]*i[2]}function nn(o){const i=o[0],w=o[1],h=o[2];return Math.sqrt(i*i+w*w+h*h)}const ln=nn;function G(o){const i=o[0],w=o[1],h=o[2];return i*i+w*w+h*h}const J=G;function K(o,i){const w=o[0]-i[0],h=o[1]-i[1],x=o[2]-i[2];return Math.sqrt(w*w+h*h+x*x)}const a=K;function O(o,i){const w=o[0]-i[0],h=o[1]-i[1],x=o[2]-i[2];return w*w+h*h+x*x}const M=O;function v(o,i){const w=i??new f(3),h=o[0],x=o[1],y=o[2],S=Math.sqrt(h*h+x*x+y*y);return S>1e-5?(w[0]=h/S,w[1]=x/S,w[2]=y/S):(w[0]=0,w[1]=0,w[2]=0),w}function E(o,i){const w=i??new f(3);return w[0]=-o[0],w[1]=-o[1],w[2]=-o[2],w}function T(o,i){const w=i??new f(3);return w[0]=o[0],w[1]=o[1],w[2]=o[2],w}const U=T;function F(o,i,w){const h=w??new f(3);return h[0]=o[0]*i[0],h[1]=o[1]*i[1],h[2]=o[2]*i[2],h}const j=F;function q(o,i,w){const h=w??new f(3);return h[0]=o[0]/i[0],h[1]=o[1]/i[1],h[2]=o[2]/i[2],h}const H=q;function X(o=1,i){const w=i??new f(3),h=Math.random()*2*Math.PI,x=Math.random()*2-1,y=Math.sqrt(1-x*x)*o;return w[0]=Math.cos(h)*y,w[1]=Math.sin(h)*y,w[2]=x*o,w}function g(o){const i=o??new f(3);return i[0]=0,i[1]=0,i[2]=0,i}function z(o,i,w){const h=w??new f(3),x=o[0],y=o[1],S=o[2],R=i[3]*x+i[7]*y+i[11]*S+i[15]||1;return h[0]=(i[0]*x+i[4]*y+i[8]*S+i[12])/R,h[1]=(i[1]*x+i[5]*y+i[9]*S+i[13])/R,h[2]=(i[2]*x+i[6]*y+i[10]*S+i[14])/R,h}function c(o,i,w){const h=w??new f(3),x=o[0],y=o[1],S=o[2];return h[0]=x*i[0*4+0]+y*i[1*4+0]+S*i[2*4+0],h[1]=x*i[0*4+1]+y*i[1*4+1]+S*i[2*4+1],h[2]=x*i[0*4+2]+y*i[1*4+2]+S*i[2*4+2],h}function r(o,i,w){const h=w??new f(3),x=o[0],y=o[1],S=o[2];return h[0]=x*i[0]+y*i[4]+S*i[8],h[1]=x*i[1]+y*i[5]+S*i[9],h[2]=x*i[2]+y*i[6]+S*i[10],h}function l(o,i,w){const h=w??new f(3),x=i[0],y=i[1],S=i[2],R=i[3]*2,V=o[0],m=o[1],L=o[2],$=y*L-S*m,Y=S*V-x*L,k=x*m-y*V;return h[0]=V+$*R+(y*k-S*Y)*2,h[1]=m+Y*R+(S*$-x*k)*2,h[2]=L+k*R+(x*Y-y*$)*2,h}function d(o,i){const w=i??new f(3);return w[0]=o[12],w[1]=o[13],w[2]=o[14],w}function A(o,i,w){const h=w??new f(3),x=i*4;return h[0]=o[x+0],h[1]=o[x+1],h[2]=o[x+2],h}function n(o,i){const w=i??new f(3),h=o[0],x=o[1],y=o[2],S=o[4],R=o[5],V=o[6],m=o[8],L=o[9],$=o[10];return w[0]=Math.sqrt(h*h+x*x+y*y),w[1]=Math.sqrt(S*S+R*R+V*V),w[2]=Math.sqrt(m*m+L*L+$*$),w}function s(o,i,w,h){const x=h??new f(3),y=[],S=[];return y[0]=o[0]-i[0],y[1]=o[1]-i[1],y[2]=o[2]-i[2],S[0]=y[0],S[1]=y[1]*Math.cos(w)-y[2]*Math.sin(w),S[2]=y[1]*Math.sin(w)+y[2]*Math.cos(w),x[0]=S[0]+i[0],x[1]=S[1]+i[1],x[2]=S[2]+i[2],x}function t(o,i,w,h){const x=h??new f(3),y=[],S=[];return y[0]=o[0]-i[0],y[1]=o[1]-i[1],y[2]=o[2]-i[2],S[0]=y[2]*Math.sin(w)+y[0]*Math.cos(w),S[1]=y[1],S[2]=y[2]*Math.cos(w)-y[0]*Math.sin(w),x[0]=S[0]+i[0],x[1]=S[1]+i[1],x[2]=S[2]+i[2],x}function e(o,i,w,h){const x=h??new f(3),y=[],S=[];return y[0]=o[0]-i[0],y[1]=o[1]-i[1],y[2]=o[2]-i[2],S[0]=y[0]*Math.cos(w)-y[1]*Math.sin(w),S[1]=y[0]*Math.sin(w)+y[1]*Math.cos(w),S[2]=y[2],x[0]=S[0]+i[0],x[1]=S[1]+i[1],x[2]=S[2]+i[2],x}function u(o,i,w){const h=w??new f(3);return v(o,h),on(h,i,h)}function p(o,i,w){const h=w??new f(3);return nn(o)>i?u(o,i,h):T(o,h)}function _(o,i,w){const h=w??new f(3);return hn(o,i,.5,h)}return{create:D,fromValues:P,set:B,ceil:W,floor:N,round:C,clamp:tn,add:vn,addScaled:En,angle:Pn,subtract:fn,sub:en,equalsApproximately:sn,equals:Rn,lerp:hn,lerpV:Sn,max:qn,min:dn,mulScalar:on,scale:zn,divScalar:On,inverse:pn,invert:Z,cross:Q,dot:an,length:nn,len:ln,lengthSq:G,lenSq:J,distance:K,dist:a,distanceSq:O,distSq:M,normalize:v,negate:E,copy:T,clone:U,multiply:F,mul:j,divide:q,div:H,random:X,zero:g,transformMat4:z,transformMat4Upper3x3:c,transformMat3:r,transformQuat:l,getTranslation:d,getAxis:A,getScaling:n,rotateX:s,rotateY:t,rotateZ:e,setLength:u,truncate:p,midpoint:_}}const ut=new Map;function bn(f){let D=ut.get(f);return D||(D=Et(f),ut.set(f,D)),D}function Pt(f){const D=bn(f);function P(n,s,t,e,u,p,_,o,i,w,h,x,y,S,R,V){const m=new f(16);return n!==void 0&&(m[0]=n,s!==void 0&&(m[1]=s,t!==void 0&&(m[2]=t,e!==void 0&&(m[3]=e,u!==void 0&&(m[4]=u,p!==void 0&&(m[5]=p,_!==void 0&&(m[6]=_,o!==void 0&&(m[7]=o,i!==void 0&&(m[8]=i,w!==void 0&&(m[9]=w,h!==void 0&&(m[10]=h,x!==void 0&&(m[11]=x,y!==void 0&&(m[12]=y,S!==void 0&&(m[13]=S,R!==void 0&&(m[14]=R,V!==void 0&&(m[15]=V)))))))))))))))),m}function B(n,s,t,e,u,p,_,o,i,w,h,x,y,S,R,V,m){const L=m??new f(16);return L[0]=n,L[1]=s,L[2]=t,L[3]=e,L[4]=u,L[5]=p,L[6]=_,L[7]=o,L[8]=i,L[9]=w,L[10]=h,L[11]=x,L[12]=y,L[13]=S,L[14]=R,L[15]=V,L}function W(n,s){const t=s??new f(16);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=0,t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=0,t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function N(n,s){const t=s??new f(16),e=n[0],u=n[1],p=n[2],_=n[3],o=e+e,i=u+u,w=p+p,h=e*o,x=u*o,y=u*i,S=p*o,R=p*i,V=p*w,m=_*o,L=_*i,$=_*w;return t[0]=1-y-V,t[1]=x+$,t[2]=S-L,t[3]=0,t[4]=x-$,t[5]=1-h-V,t[6]=R+m,t[7]=0,t[8]=S+L,t[9]=R-m,t[10]=1-h-y,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function C(n,s){const t=s??new f(16);return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t[4]=-n[4],t[5]=-n[5],t[6]=-n[6],t[7]=-n[7],t[8]=-n[8],t[9]=-n[9],t[10]=-n[10],t[11]=-n[11],t[12]=-n[12],t[13]=-n[13],t[14]=-n[14],t[15]=-n[15],t}function tn(n,s){const t=s??new f(16);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t}const vn=tn;function En(n,s){return Math.abs(n[0]-s[0])<I&&Math.abs(n[1]-s[1])<I&&Math.abs(n[2]-s[2])<I&&Math.abs(n[3]-s[3])<I&&Math.abs(n[4]-s[4])<I&&Math.abs(n[5]-s[5])<I&&Math.abs(n[6]-s[6])<I&&Math.abs(n[7]-s[7])<I&&Math.abs(n[8]-s[8])<I&&Math.abs(n[9]-s[9])<I&&Math.abs(n[10]-s[10])<I&&Math.abs(n[11]-s[11])<I&&Math.abs(n[12]-s[12])<I&&Math.abs(n[13]-s[13])<I&&Math.abs(n[14]-s[14])<I&&Math.abs(n[15]-s[15])<I}function Pn(n,s){return n[0]===s[0]&&n[1]===s[1]&&n[2]===s[2]&&n[3]===s[3]&&n[4]===s[4]&&n[5]===s[5]&&n[6]===s[6]&&n[7]===s[7]&&n[8]===s[8]&&n[9]===s[9]&&n[10]===s[10]&&n[11]===s[11]&&n[12]===s[12]&&n[13]===s[13]&&n[14]===s[14]&&n[15]===s[15]}function fn(n){const s=n??new f(16);return s[0]=1,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=1,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=1,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,s}function en(n,s){const t=s??new f(16);if(t===n){let Y;return Y=n[1],n[1]=n[4],n[4]=Y,Y=n[2],n[2]=n[8],n[8]=Y,Y=n[3],n[3]=n[12],n[12]=Y,Y=n[6],n[6]=n[9],n[9]=Y,Y=n[7],n[7]=n[13],n[13]=Y,Y=n[11],n[11]=n[14],n[14]=Y,t}const e=n[0*4+0],u=n[0*4+1],p=n[0*4+2],_=n[0*4+3],o=n[1*4+0],i=n[1*4+1],w=n[1*4+2],h=n[1*4+3],x=n[2*4+0],y=n[2*4+1],S=n[2*4+2],R=n[2*4+3],V=n[3*4+0],m=n[3*4+1],L=n[3*4+2],$=n[3*4+3];return t[0]=e,t[1]=o,t[2]=x,t[3]=V,t[4]=u,t[5]=i,t[6]=y,t[7]=m,t[8]=p,t[9]=w,t[10]=S,t[11]=L,t[12]=_,t[13]=h,t[14]=R,t[15]=$,t}function sn(n,s){const t=s??new f(16),e=n[0*4+0],u=n[0*4+1],p=n[0*4+2],_=n[0*4+3],o=n[1*4+0],i=n[1*4+1],w=n[1*4+2],h=n[1*4+3],x=n[2*4+0],y=n[2*4+1],S=n[2*4+2],R=n[2*4+3],V=n[3*4+0],m=n[3*4+1],L=n[3*4+2],$=n[3*4+3],Y=S*$,k=L*R,cn=w*$,rn=L*h,wn=w*R,gn=S*h,Mn=p*$,Dn=L*_,xn=p*R,yn=S*_,An=p*h,Tn=w*_,mn=x*m,Ln=V*y,Hn=o*m,Vn=V*i,In=o*y,Wn=x*i,$n=e*m,jn=V*u,Yn=e*y,Xn=x*u,Zn=e*i,Qn=o*u,nt=Y*i+rn*y+wn*m-(k*i+cn*y+gn*m),tt=k*u+Mn*y+yn*m-(Y*u+Dn*y+xn*m),et=cn*u+Dn*i+An*m-(rn*u+Mn*i+Tn*m),ot=gn*u+xn*i+Tn*y-(wn*u+yn*i+An*y),_n=1/(e*nt+o*tt+x*et+V*ot);return t[0]=_n*nt,t[1]=_n*tt,t[2]=_n*et,t[3]=_n*ot,t[4]=_n*(k*o+cn*x+gn*V-(Y*o+rn*x+wn*V)),t[5]=_n*(Y*e+Dn*x+xn*V-(k*e+Mn*x+yn*V)),t[6]=_n*(rn*e+Mn*o+Tn*V-(cn*e+Dn*o+An*V)),t[7]=_n*(wn*e+yn*o+An*x-(gn*e+xn*o+Tn*x)),t[8]=_n*(mn*h+Vn*R+In*$-(Ln*h+Hn*R+Wn*$)),t[9]=_n*(Ln*_+$n*R+Xn*$-(mn*_+jn*R+Yn*$)),t[10]=_n*(Hn*_+jn*h+Zn*$-(Vn*_+$n*h+Qn*$)),t[11]=_n*(Wn*_+Yn*h+Qn*R-(In*_+Xn*h+Zn*R)),t[12]=_n*(Hn*S+Wn*L+Ln*w-(In*L+mn*w+Vn*S)),t[13]=_n*(Yn*L+mn*p+jn*S-($n*S+Xn*L+Ln*p)),t[14]=_n*($n*w+Qn*L+Vn*p-(Zn*L+Hn*p+jn*w)),t[15]=_n*(Zn*S+In*p+Xn*w-(Yn*w+Qn*S+Wn*p)),t}function Rn(n){const s=n[0],t=n[0*4+1],e=n[0*4+2],u=n[0*4+3],p=n[1*4+0],_=n[1*4+1],o=n[1*4+2],i=n[1*4+3],w=n[2*4+0],h=n[2*4+1],x=n[2*4+2],y=n[2*4+3],S=n[3*4+0],R=n[3*4+1],V=n[3*4+2],m=n[3*4+3],L=x*m,$=V*y,Y=o*m,k=V*i,cn=o*y,rn=x*i,wn=e*m,gn=V*u,Mn=e*y,Dn=x*u,xn=e*i,yn=o*u,An=L*_+k*h+cn*R-($*_+Y*h+rn*R),Tn=$*t+wn*h+Dn*R-(L*t+gn*h+Mn*R),mn=Y*t+gn*_+xn*R-(k*t+wn*_+yn*R),Ln=rn*t+Mn*_+yn*h-(cn*t+Dn*_+xn*h);return s*An+p*Tn+w*mn+S*Ln}const hn=sn;function Sn(n,s,t){const e=t??new f(16),u=n[0],p=n[1],_=n[2],o=n[3],i=n[4],w=n[5],h=n[6],x=n[7],y=n[8],S=n[9],R=n[10],V=n[11],m=n[12],L=n[13],$=n[14],Y=n[15],k=s[0],cn=s[1],rn=s[2],wn=s[3],gn=s[4],Mn=s[5],Dn=s[6],xn=s[7],yn=s[8],An=s[9],Tn=s[10],mn=s[11],Ln=s[12],Hn=s[13],Vn=s[14],In=s[15];return e[0]=u*k+i*cn+y*rn+m*wn,e[1]=p*k+w*cn+S*rn+L*wn,e[2]=_*k+h*cn+R*rn+$*wn,e[3]=o*k+x*cn+V*rn+Y*wn,e[4]=u*gn+i*Mn+y*Dn+m*xn,e[5]=p*gn+w*Mn+S*Dn+L*xn,e[6]=_*gn+h*Mn+R*Dn+$*xn,e[7]=o*gn+x*Mn+V*Dn+Y*xn,e[8]=u*yn+i*An+y*Tn+m*mn,e[9]=p*yn+w*An+S*Tn+L*mn,e[10]=_*yn+h*An+R*Tn+$*mn,e[11]=o*yn+x*An+V*Tn+Y*mn,e[12]=u*Ln+i*Hn+y*Vn+m*In,e[13]=p*Ln+w*Hn+S*Vn+L*In,e[14]=_*Ln+h*Hn+R*Vn+$*In,e[15]=o*Ln+x*Hn+V*Vn+Y*In,e}const qn=Sn;function dn(n,s,t){const e=t??fn();return n!==e&&(e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11]),e[12]=s[0],e[13]=s[1],e[14]=s[2],e[15]=1,e}function on(n,s){const t=s??D.create();return t[0]=n[12],t[1]=n[13],t[2]=n[14],t}function zn(n,s,t){const e=t??D.create(),u=s*4;return e[0]=n[u+0],e[1]=n[u+1],e[2]=n[u+2],e}function On(n,s,t,e){const u=e===n?e:tn(n,e),p=t*4;return u[p+0]=s[0],u[p+1]=s[1],u[p+2]=s[2],u}function pn(n,s){const t=s??D.create(),e=n[0],u=n[1],p=n[2],_=n[4],o=n[5],i=n[6],w=n[8],h=n[9],x=n[10];return t[0]=Math.sqrt(e*e+u*u+p*p),t[1]=Math.sqrt(_*_+o*o+i*i),t[2]=Math.sqrt(w*w+h*h+x*x),t}function Z(n,s,t,e,u){const p=u??new f(16),_=Math.tan(Math.PI*.5-.5*n);if(p[0]=_/s,p[1]=0,p[2]=0,p[3]=0,p[4]=0,p[5]=_,p[6]=0,p[7]=0,p[8]=0,p[9]=0,p[11]=-1,p[12]=0,p[13]=0,p[15]=0,Number.isFinite(e)){const o=1/(t-e);p[10]=e*o,p[14]=e*t*o}else p[10]=-1,p[14]=-t;return p}function Q(n,s,t,e=1/0,u){const p=u??new f(16),_=1/Math.tan(n*.5);if(p[0]=_/s,p[1]=0,p[2]=0,p[3]=0,p[4]=0,p[5]=_,p[6]=0,p[7]=0,p[8]=0,p[9]=0,p[11]=-1,p[12]=0,p[13]=0,p[15]=0,e===1/0)p[10]=0,p[14]=t;else{const o=1/(e-t);p[10]=t*o,p[14]=e*t*o}return p}function an(n,s,t,e,u,p,_){const o=_??new f(16);return o[0]=2/(s-n),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(e-t),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1/(u-p),o[11]=0,o[12]=(s+n)/(n-s),o[13]=(e+t)/(t-e),o[14]=u/(u-p),o[15]=1,o}function nn(n,s,t,e,u,p,_){const o=_??new f(16),i=s-n,w=e-t,h=u-p;return o[0]=2*u/i,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*u/w,o[6]=0,o[7]=0,o[8]=(n+s)/i,o[9]=(e+t)/w,o[10]=p/h,o[11]=-1,o[12]=0,o[13]=0,o[14]=u*p/h,o[15]=0,o}function ln(n,s,t,e,u,p=1/0,_){const o=_??new f(16),i=s-n,w=e-t;if(o[0]=2*u/i,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*u/w,o[6]=0,o[7]=0,o[8]=(n+s)/i,o[9]=(e+t)/w,o[11]=-1,o[12]=0,o[13]=0,o[15]=0,p===1/0)o[10]=0,o[14]=u;else{const h=1/(p-u);o[10]=u*h,o[14]=p*u*h}return o}const G=D.create(),J=D.create(),K=D.create();function a(n,s,t,e){const u=e??new f(16);return D.normalize(D.subtract(s,n,K),K),D.normalize(D.cross(t,K,G),G),D.normalize(D.cross(K,G,J),J),u[0]=G[0],u[1]=G[1],u[2]=G[2],u[3]=0,u[4]=J[0],u[5]=J[1],u[6]=J[2],u[7]=0,u[8]=K[0],u[9]=K[1],u[10]=K[2],u[11]=0,u[12]=n[0],u[13]=n[1],u[14]=n[2],u[15]=1,u}function O(n,s,t,e){const u=e??new f(16);return D.normalize(D.subtract(n,s,K),K),D.normalize(D.cross(t,K,G),G),D.normalize(D.cross(K,G,J),J),u[0]=G[0],u[1]=G[1],u[2]=G[2],u[3]=0,u[4]=J[0],u[5]=J[1],u[6]=J[2],u[7]=0,u[8]=K[0],u[9]=K[1],u[10]=K[2],u[11]=0,u[12]=n[0],u[13]=n[1],u[14]=n[2],u[15]=1,u}function M(n,s,t,e){const u=e??new f(16);return D.normalize(D.subtract(n,s,K),K),D.normalize(D.cross(t,K,G),G),D.normalize(D.cross(K,G,J),J),u[0]=G[0],u[1]=J[0],u[2]=K[0],u[3]=0,u[4]=G[1],u[5]=J[1],u[6]=K[1],u[7]=0,u[8]=G[2],u[9]=J[2],u[10]=K[2],u[11]=0,u[12]=-(G[0]*n[0]+G[1]*n[1]+G[2]*n[2]),u[13]=-(J[0]*n[0]+J[1]*n[1]+J[2]*n[2]),u[14]=-(K[0]*n[0]+K[1]*n[1]+K[2]*n[2]),u[15]=1,u}function v(n,s){const t=s??new f(16);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t}function E(n,s,t){const e=t??new f(16),u=s[0],p=s[1],_=s[2],o=n[0],i=n[1],w=n[2],h=n[3],x=n[1*4+0],y=n[1*4+1],S=n[1*4+2],R=n[1*4+3],V=n[2*4+0],m=n[2*4+1],L=n[2*4+2],$=n[2*4+3],Y=n[3*4+0],k=n[3*4+1],cn=n[3*4+2],rn=n[3*4+3];return n!==e&&(e[0]=o,e[1]=i,e[2]=w,e[3]=h,e[4]=x,e[5]=y,e[6]=S,e[7]=R,e[8]=V,e[9]=m,e[10]=L,e[11]=$),e[12]=o*u+x*p+V*_+Y,e[13]=i*u+y*p+m*_+k,e[14]=w*u+S*p+L*_+cn,e[15]=h*u+R*p+$*_+rn,e}function T(n,s){const t=s??new f(16),e=Math.cos(n),u=Math.sin(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=u,t[7]=0,t[8]=0,t[9]=-u,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function U(n,s,t){const e=t??new f(16),u=n[4],p=n[5],_=n[6],o=n[7],i=n[8],w=n[9],h=n[10],x=n[11],y=Math.cos(s),S=Math.sin(s);return e[4]=y*u+S*i,e[5]=y*p+S*w,e[6]=y*_+S*h,e[7]=y*o+S*x,e[8]=y*i-S*u,e[9]=y*w-S*p,e[10]=y*h-S*_,e[11]=y*x-S*o,n!==e&&(e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}function F(n,s){const t=s??new f(16),e=Math.cos(n),u=Math.sin(n);return t[0]=e,t[1]=0,t[2]=-u,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=u,t[9]=0,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function j(n,s,t){const e=t??new f(16),u=n[0*4+0],p=n[0*4+1],_=n[0*4+2],o=n[0*4+3],i=n[2*4+0],w=n[2*4+1],h=n[2*4+2],x=n[2*4+3],y=Math.cos(s),S=Math.sin(s);return e[0]=y*u-S*i,e[1]=y*p-S*w,e[2]=y*_-S*h,e[3]=y*o-S*x,e[8]=y*i+S*u,e[9]=y*w+S*p,e[10]=y*h+S*_,e[11]=y*x+S*o,n!==e&&(e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}function q(n,s){const t=s??new f(16),e=Math.cos(n),u=Math.sin(n);return t[0]=e,t[1]=u,t[2]=0,t[3]=0,t[4]=-u,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function H(n,s,t){const e=t??new f(16),u=n[0*4+0],p=n[0*4+1],_=n[0*4+2],o=n[0*4+3],i=n[1*4+0],w=n[1*4+1],h=n[1*4+2],x=n[1*4+3],y=Math.cos(s),S=Math.sin(s);return e[0]=y*u+S*i,e[1]=y*p+S*w,e[2]=y*_+S*h,e[3]=y*o+S*x,e[4]=y*i-S*u,e[5]=y*w-S*p,e[6]=y*h-S*_,e[7]=y*x-S*o,n!==e&&(e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}function X(n,s,t){const e=t??new f(16);let u=n[0],p=n[1],_=n[2];const o=Math.sqrt(u*u+p*p+_*_);u/=o,p/=o,_/=o;const i=u*u,w=p*p,h=_*_,x=Math.cos(s),y=Math.sin(s),S=1-x;return e[0]=i+(1-i)*x,e[1]=u*p*S+_*y,e[2]=u*_*S-p*y,e[3]=0,e[4]=u*p*S-_*y,e[5]=w+(1-w)*x,e[6]=p*_*S+u*y,e[7]=0,e[8]=u*_*S+p*y,e[9]=p*_*S-u*y,e[10]=h+(1-h)*x,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}const g=X;function z(n,s,t,e){const u=e??new f(16);let p=s[0],_=s[1],o=s[2];const i=Math.sqrt(p*p+_*_+o*o);p/=i,_/=i,o/=i;const w=p*p,h=_*_,x=o*o,y=Math.cos(t),S=Math.sin(t),R=1-y,V=w+(1-w)*y,m=p*_*R+o*S,L=p*o*R-_*S,$=p*_*R-o*S,Y=h+(1-h)*y,k=_*o*R+p*S,cn=p*o*R+_*S,rn=_*o*R-p*S,wn=x+(1-x)*y,gn=n[0],Mn=n[1],Dn=n[2],xn=n[3],yn=n[4],An=n[5],Tn=n[6],mn=n[7],Ln=n[8],Hn=n[9],Vn=n[10],In=n[11];return u[0]=V*gn+m*yn+L*Ln,u[1]=V*Mn+m*An+L*Hn,u[2]=V*Dn+m*Tn+L*Vn,u[3]=V*xn+m*mn+L*In,u[4]=$*gn+Y*yn+k*Ln,u[5]=$*Mn+Y*An+k*Hn,u[6]=$*Dn+Y*Tn+k*Vn,u[7]=$*xn+Y*mn+k*In,u[8]=cn*gn+rn*yn+wn*Ln,u[9]=cn*Mn+rn*An+wn*Hn,u[10]=cn*Dn+rn*Tn+wn*Vn,u[11]=cn*xn+rn*mn+wn*In,n!==u&&(u[12]=n[12],u[13]=n[13],u[14]=n[14],u[15]=n[15]),u}const c=z;function r(n,s){const t=s??new f(16);return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function l(n,s,t){const e=t??new f(16),u=s[0],p=s[1],_=s[2];return e[0]=u*n[0*4+0],e[1]=u*n[0*4+1],e[2]=u*n[0*4+2],e[3]=u*n[0*4+3],e[4]=p*n[1*4+0],e[5]=p*n[1*4+1],e[6]=p*n[1*4+2],e[7]=p*n[1*4+3],e[8]=_*n[2*4+0],e[9]=_*n[2*4+1],e[10]=_*n[2*4+2],e[11]=_*n[2*4+3],n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}function d(n,s){const t=s??new f(16);return t[0]=n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function A(n,s,t){const e=t??new f(16);return e[0]=s*n[0*4+0],e[1]=s*n[0*4+1],e[2]=s*n[0*4+2],e[3]=s*n[0*4+3],e[4]=s*n[1*4+0],e[5]=s*n[1*4+1],e[6]=s*n[1*4+2],e[7]=s*n[1*4+3],e[8]=s*n[2*4+0],e[9]=s*n[2*4+1],e[10]=s*n[2*4+2],e[11]=s*n[2*4+3],n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}return{create:P,set:B,fromMat3:W,fromQuat:N,negate:C,copy:tn,clone:vn,equalsApproximately:En,equals:Pn,identity:fn,transpose:en,inverse:sn,determinant:Rn,invert:hn,multiply:Sn,mul:qn,setTranslation:dn,getTranslation:on,getAxis:zn,setAxis:On,getScaling:pn,perspective:Z,perspectiveReverseZ:Q,ortho:an,frustum:nn,frustumReverseZ:ln,aim:a,cameraAim:O,lookAt:M,translation:v,translate:E,rotationX:T,rotateX:U,rotationY:F,rotateY:j,rotationZ:q,rotateZ:H,axisRotation:X,rotation:g,axisRotate:z,rotate:c,scaling:r,scale:l,uniformScaling:d,uniformScale:A}}const ft=new Map;function Rt(f){let D=ft.get(f);return D||(D=Pt(f),ft.set(f,D)),D}function qt(f){const D=bn(f);function P(g,z,c,r){const l=new f(4);return g!==void 0&&(l[0]=g,z!==void 0&&(l[1]=z,c!==void 0&&(l[2]=c,r!==void 0&&(l[3]=r)))),l}const B=P;function W(g,z,c,r,l){const d=l??new f(4);return d[0]=g,d[1]=z,d[2]=c,d[3]=r,d}function N(g,z,c){const r=c??new f(4),l=z*.5,d=Math.sin(l);return r[0]=d*g[0],r[1]=d*g[1],r[2]=d*g[2],r[3]=Math.cos(l),r}function C(g,z){const c=z??D.create(3),r=Math.acos(g[3])*2,l=Math.sin(r*.5);return l>I?(c[0]=g[0]/l,c[1]=g[1]/l,c[2]=g[2]/l):(c[0]=1,c[1]=0,c[2]=0),{angle:r,axis:c}}function tn(g,z){const c=nn(g,z);return Math.acos(2*c*c-1)}function vn(g,z,c){const r=c??new f(4),l=g[0],d=g[1],A=g[2],n=g[3],s=z[0],t=z[1],e=z[2],u=z[3];return r[0]=l*u+n*s+d*e-A*t,r[1]=d*u+n*t+A*s-l*e,r[2]=A*u+n*e+l*t-d*s,r[3]=n*u-l*s-d*t-A*e,r}const En=vn;function Pn(g,z,c){const r=c??new f(4),l=z*.5,d=g[0],A=g[1],n=g[2],s=g[3],t=Math.sin(l),e=Math.cos(l);return r[0]=d*e+s*t,r[1]=A*e+n*t,r[2]=n*e-A*t,r[3]=s*e-d*t,r}function fn(g,z,c){const r=c??new f(4),l=z*.5,d=g[0],A=g[1],n=g[2],s=g[3],t=Math.sin(l),e=Math.cos(l);return r[0]=d*e-n*t,r[1]=A*e+s*t,r[2]=n*e+d*t,r[3]=s*e-A*t,r}function en(g,z,c){const r=c??new f(4),l=z*.5,d=g[0],A=g[1],n=g[2],s=g[3],t=Math.sin(l),e=Math.cos(l);return r[0]=d*e+A*t,r[1]=A*e-d*t,r[2]=n*e+s*t,r[3]=s*e-n*t,r}function sn(g,z,c,r){const l=r??new f(4),d=g[0],A=g[1],n=g[2],s=g[3];let t=z[0],e=z[1],u=z[2],p=z[3],_=d*t+A*e+n*u+s*p;_<0&&(_=-_,t=-t,e=-e,u=-u,p=-p);let o,i;if(1-_>I){const w=Math.acos(_),h=Math.sin(w);o=Math.sin((1-c)*w)/h,i=Math.sin(c*w)/h}else o=1-c,i=c;return l[0]=o*d+i*t,l[1]=o*A+i*e,l[2]=o*n+i*u,l[3]=o*s+i*p,l}function Rn(g,z){const c=z??new f(4),r=g[0],l=g[1],d=g[2],A=g[3],n=r*r+l*l+d*d+A*A,s=n?1/n:0;return c[0]=-r*s,c[1]=-l*s,c[2]=-d*s,c[3]=A*s,c}function hn(g,z){const c=z??new f(4);return c[0]=-g[0],c[1]=-g[1],c[2]=-g[2],c[3]=g[3],c}function Sn(g,z){const c=z??new f(4),r=g[0]+g[5]+g[10];if(r>0){const l=Math.sqrt(r+1);c[3]=.5*l;const d=.5/l;c[0]=(g[6]-g[9])*d,c[1]=(g[8]-g[2])*d,c[2]=(g[1]-g[4])*d}else{let l=0;g[5]>g[0]&&(l=1),g[10]>g[l*4+l]&&(l=2);const d=(l+1)%3,A=(l+2)%3,n=Math.sqrt(g[l*4+l]-g[d*4+d]-g[A*4+A]+1);c[l]=.5*n;const s=.5/n;c[3]=(g[d*4+A]-g[A*4+d])*s,c[d]=(g[d*4+l]+g[l*4+d])*s,c[A]=(g[A*4+l]+g[l*4+A])*s}return c}function qn(g,z,c,r,l){const d=l??new f(4),A=g*.5,n=z*.5,s=c*.5,t=Math.sin(A),e=Math.cos(A),u=Math.sin(n),p=Math.cos(n),_=Math.sin(s),o=Math.cos(s);switch(r){case"xyz":d[0]=t*p*o+e*u*_,d[1]=e*u*o-t*p*_,d[2]=e*p*_+t*u*o,d[3]=e*p*o-t*u*_;break;case"xzy":d[0]=t*p*o-e*u*_,d[1]=e*u*o-t*p*_,d[2]=e*p*_+t*u*o,d[3]=e*p*o+t*u*_;break;case"yxz":d[0]=t*p*o+e*u*_,d[1]=e*u*o-t*p*_,d[2]=e*p*_-t*u*o,d[3]=e*p*o+t*u*_;break;case"yzx":d[0]=t*p*o+e*u*_,d[1]=e*u*o+t*p*_,d[2]=e*p*_-t*u*o,d[3]=e*p*o-t*u*_;break;case"zxy":d[0]=t*p*o-e*u*_,d[1]=e*u*o+t*p*_,d[2]=e*p*_+t*u*o,d[3]=e*p*o-t*u*_;break;case"zyx":d[0]=t*p*o-e*u*_,d[1]=e*u*o+t*p*_,d[2]=e*p*_-t*u*o,d[3]=e*p*o+t*u*_;break;default:throw new Error(`Unknown rotation order: ${r}`)}return d}function dn(g,z){const c=z??new f(4);return c[0]=g[0],c[1]=g[1],c[2]=g[2],c[3]=g[3],c}const on=dn;function zn(g,z,c){const r=c??new f(4);return r[0]=g[0]+z[0],r[1]=g[1]+z[1],r[2]=g[2]+z[2],r[3]=g[3]+z[3],r}function On(g,z,c){const r=c??new f(4);return r[0]=g[0]-z[0],r[1]=g[1]-z[1],r[2]=g[2]-z[2],r[3]=g[3]-z[3],r}const pn=On;function Z(g,z,c){const r=c??new f(4);return r[0]=g[0]*z,r[1]=g[1]*z,r[2]=g[2]*z,r[3]=g[3]*z,r}const Q=Z;function an(g,z,c){const r=c??new f(4);return r[0]=g[0]/z,r[1]=g[1]/z,r[2]=g[2]/z,r[3]=g[3]/z,r}function nn(g,z){return g[0]*z[0]+g[1]*z[1]+g[2]*z[2]+g[3]*z[3]}function ln(g,z,c,r){const l=r??new f(4);return l[0]=g[0]+c*(z[0]-g[0]),l[1]=g[1]+c*(z[1]-g[1]),l[2]=g[2]+c*(z[2]-g[2]),l[3]=g[3]+c*(z[3]-g[3]),l}function G(g){const z=g[0],c=g[1],r=g[2],l=g[3];return Math.sqrt(z*z+c*c+r*r+l*l)}const J=G;function K(g){const z=g[0],c=g[1],r=g[2],l=g[3];return z*z+c*c+r*r+l*l}const a=K;function O(g,z){const c=z??new f(4),r=g[0],l=g[1],d=g[2],A=g[3],n=Math.sqrt(r*r+l*l+d*d+A*A);return n>1e-5?(c[0]=r/n,c[1]=l/n,c[2]=d/n,c[3]=A/n):(c[0]=0,c[1]=0,c[2]=0,c[3]=1),c}function M(g,z){return Math.abs(g[0]-z[0])<I&&Math.abs(g[1]-z[1])<I&&Math.abs(g[2]-z[2])<I&&Math.abs(g[3]-z[3])<I}function v(g,z){return g[0]===z[0]&&g[1]===z[1]&&g[2]===z[2]&&g[3]===z[3]}function E(g){const z=g??new f(4);return z[0]=0,z[1]=0,z[2]=0,z[3]=1,z}const T=D.create(),U=D.create(),F=D.create();function j(g,z,c){const r=c??new f(4),l=D.dot(g,z);return l<-.999999?(D.cross(U,g,T),D.len(T)<1e-6&&D.cross(F,g,T),D.normalize(T,T),N(T,Math.PI,r),r):l>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(D.cross(g,z,T),r[0]=T[0],r[1]=T[1],r[2]=T[2],r[3]=1+l,O(r,r))}const q=new f(4),H=new f(4);function X(g,z,c,r,l,d){const A=d??new f(4);return sn(g,r,l,q),sn(z,c,l,H),sn(q,H,2*l*(1-l),A),A}return{create:P,fromValues:B,set:W,fromAxisAngle:N,toAxisAngle:C,angle:tn,multiply:vn,mul:En,rotateX:Pn,rotateY:fn,rotateZ:en,slerp:sn,inverse:Rn,conjugate:hn,fromMat:Sn,fromEuler:qn,copy:dn,clone:on,add:zn,subtract:On,sub:pn,mulScalar:Z,scale:Q,divScalar:an,dot:nn,lerp:ln,length:G,len:J,lengthSq:K,lenSq:a,normalize:O,equalsApproximately:M,equals:v,identity:E,rotationTo:j,sqlerp:X}}const at=new Map;function Ht(f){let D=at.get(f);return D||(D=qt(f),at.set(f,D)),D}function Vt(f){function D(c,r,l,d){const A=new f(4);return c!==void 0&&(A[0]=c,r!==void 0&&(A[1]=r,l!==void 0&&(A[2]=l,d!==void 0&&(A[3]=d)))),A}const P=D;function B(c,r,l,d,A){const n=A??new f(4);return n[0]=c,n[1]=r,n[2]=l,n[3]=d,n}function W(c,r){const l=r??new f(4);return l[0]=Math.ceil(c[0]),l[1]=Math.ceil(c[1]),l[2]=Math.ceil(c[2]),l[3]=Math.ceil(c[3]),l}function N(c,r){const l=r??new f(4);return l[0]=Math.floor(c[0]),l[1]=Math.floor(c[1]),l[2]=Math.floor(c[2]),l[3]=Math.floor(c[3]),l}function C(c,r){const l=r??new f(4);return l[0]=Math.round(c[0]),l[1]=Math.round(c[1]),l[2]=Math.round(c[2]),l[3]=Math.round(c[3]),l}function tn(c,r=0,l=1,d){const A=d??new f(4);return A[0]=Math.min(l,Math.max(r,c[0])),A[1]=Math.min(l,Math.max(r,c[1])),A[2]=Math.min(l,Math.max(r,c[2])),A[3]=Math.min(l,Math.max(r,c[3])),A}function vn(c,r,l){const d=l??new f(4);return d[0]=c[0]+r[0],d[1]=c[1]+r[1],d[2]=c[2]+r[2],d[3]=c[3]+r[3],d}function En(c,r,l,d){const A=d??new f(4);return A[0]=c[0]+r[0]*l,A[1]=c[1]+r[1]*l,A[2]=c[2]+r[2]*l,A[3]=c[3]+r[3]*l,A}function Pn(c,r,l){const d=l??new f(4);return d[0]=c[0]-r[0],d[1]=c[1]-r[1],d[2]=c[2]-r[2],d[3]=c[3]-r[3],d}const fn=Pn;function en(c,r){return Math.abs(c[0]-r[0])<I&&Math.abs(c[1]-r[1])<I&&Math.abs(c[2]-r[2])<I&&Math.abs(c[3]-r[3])<I}function sn(c,r){return c[0]===r[0]&&c[1]===r[1]&&c[2]===r[2]&&c[3]===r[3]}function Rn(c,r,l,d){const A=d??new f(4);return A[0]=c[0]+l*(r[0]-c[0]),A[1]=c[1]+l*(r[1]-c[1]),A[2]=c[2]+l*(r[2]-c[2]),A[3]=c[3]+l*(r[3]-c[3]),A}function hn(c,r,l,d){const A=d??new f(4);return A[0]=c[0]+l[0]*(r[0]-c[0]),A[1]=c[1]+l[1]*(r[1]-c[1]),A[2]=c[2]+l[2]*(r[2]-c[2]),A[3]=c[3]+l[3]*(r[3]-c[3]),A}function Sn(c,r,l){const d=l??new f(4);return d[0]=Math.max(c[0],r[0]),d[1]=Math.max(c[1],r[1]),d[2]=Math.max(c[2],r[2]),d[3]=Math.max(c[3],r[3]),d}function qn(c,r,l){const d=l??new f(4);return d[0]=Math.min(c[0],r[0]),d[1]=Math.min(c[1],r[1]),d[2]=Math.min(c[2],r[2]),d[3]=Math.min(c[3],r[3]),d}function dn(c,r,l){const d=l??new f(4);return d[0]=c[0]*r,d[1]=c[1]*r,d[2]=c[2]*r,d[3]=c[3]*r,d}const on=dn;function zn(c,r,l){const d=l??new f(4);return d[0]=c[0]/r,d[1]=c[1]/r,d[2]=c[2]/r,d[3]=c[3]/r,d}function On(c,r){const l=r??new f(4);return l[0]=1/c[0],l[1]=1/c[1],l[2]=1/c[2],l[3]=1/c[3],l}const pn=On;function Z(c,r){return c[0]*r[0]+c[1]*r[1]+c[2]*r[2]+c[3]*r[3]}function Q(c){const r=c[0],l=c[1],d=c[2],A=c[3];return Math.sqrt(r*r+l*l+d*d+A*A)}const an=Q;function nn(c){const r=c[0],l=c[1],d=c[2],A=c[3];return r*r+l*l+d*d+A*A}const ln=nn;function G(c,r){const l=c[0]-r[0],d=c[1]-r[1],A=c[2]-r[2],n=c[3]-r[3];return Math.sqrt(l*l+d*d+A*A+n*n)}const J=G;function K(c,r){const l=c[0]-r[0],d=c[1]-r[1],A=c[2]-r[2],n=c[3]-r[3];return l*l+d*d+A*A+n*n}const a=K;function O(c,r){const l=r??new f(4),d=c[0],A=c[1],n=c[2],s=c[3],t=Math.sqrt(d*d+A*A+n*n+s*s);return t>1e-5?(l[0]=d/t,l[1]=A/t,l[2]=n/t,l[3]=s/t):(l[0]=0,l[1]=0,l[2]=0,l[3]=0),l}function M(c,r){const l=r??new f(4);return l[0]=-c[0],l[1]=-c[1],l[2]=-c[2],l[3]=-c[3],l}function v(c,r){const l=r??new f(4);return l[0]=c[0],l[1]=c[1],l[2]=c[2],l[3]=c[3],l}const E=v;function T(c,r,l){const d=l??new f(4);return d[0]=c[0]*r[0],d[1]=c[1]*r[1],d[2]=c[2]*r[2],d[3]=c[3]*r[3],d}const U=T;function F(c,r,l){const d=l??new f(4);return d[0]=c[0]/r[0],d[1]=c[1]/r[1],d[2]=c[2]/r[2],d[3]=c[3]/r[3],d}const j=F;function q(c){const r=c??new f(4);return r[0]=0,r[1]=0,r[2]=0,r[3]=0,r}function H(c,r,l){const d=l??new f(4),A=c[0],n=c[1],s=c[2],t=c[3];return d[0]=r[0]*A+r[4]*n+r[8]*s+r[12]*t,d[1]=r[1]*A+r[5]*n+r[9]*s+r[13]*t,d[2]=r[2]*A+r[6]*n+r[10]*s+r[14]*t,d[3]=r[3]*A+r[7]*n+r[11]*s+r[15]*t,d}function X(c,r,l){const d=l??new f(4);return O(c,d),dn(d,r,d)}function g(c,r,l){const d=l??new f(4);return Q(c)>r?X(c,r,d):v(c,d)}function z(c,r,l){const d=l??new f(4);return Rn(c,r,.5,d)}return{create:D,fromValues:P,set:B,ceil:W,floor:N,round:C,clamp:tn,add:vn,addScaled:En,subtract:Pn,sub:fn,equalsApproximately:en,equals:sn,lerp:Rn,lerpV:hn,max:Sn,min:qn,mulScalar:dn,scale:on,divScalar:zn,inverse:On,invert:pn,dot:Z,length:Q,len:an,lengthSq:nn,lenSq:ln,distance:G,dist:J,distanceSq:K,distSq:a,normalize:O,negate:M,copy:v,clone:E,multiply:T,mul:U,divide:F,div:j,zero:q,transformMat4:H,setLength:X,truncate:g,midpoint:z}}const lt=new Map;function It(f){let D=lt.get(f);return D||(D=Vt(f),lt.set(f,D)),D}function Cn(f,D,P,B,W,N){return{mat4:Rt(f),mat3:Lt(D),quat:Ht(P),vec2:pt(B),vec3:bn(W),vec4:It(N)}}const{mat4:Kn,vec2:Bt,vec3:Bn,vec4:un}=Cn(Float32Array,Float32Array,Float32Array,Float32Array,Float32Array,Float32Array);Cn(Float64Array,Float64Array,Float64Array,Float64Array,Float64Array,Float64Array);Cn(yt,Array,Array,Array,Array,Array);const Nt=`struct Uniforms {
  projectionMatrix : mat4x4f,
  modelViewMatrix : mat4x4f,
  fogColor : vec4f,
  lightDirection : vec4f,
  cameraPosition: vec4f,
  config : vec4f,
}
@binding(0) @group(0) var<uniform> uniforms : Uniforms;

struct VertexOut {
  @builtin(position) position : vec4f,
  @location(0) color : vec4f,
  @location(1) normal : vec3f,
  @location(2) fogDepth : f32
}

const WATER_COLOR = vec4(0.06, 0.37, 0.61, 1.0);
const SAND_COLOR = vec4(0.8, 0.52, 0.24, 1.0);
const GRASS_COLOR = vec4(0.13, 0.53, 0.0, 1.0);
const STONE_COLOR = vec4(0.65, 0.65, 0.65, 1.0);
const SNOW_COLOR = vec4(1.0, 1.0, 1.0, 1.0);

const WATER_THRESHOLD = 0.5;
const SAND_THRESHOLD = 0.51;
const GRASS_THRESHOLD = 0.55;
const STONE_THRESHOLD = 0.85;
const SNOW_THRESHOLD = 1.0;

const normalOffsetDelta = 0.032;

const terrainFractalLayers = 5;
const terrainAmplitudeFreq = 0.3;
const waveScale = 0.1;

const uLightDiffuse = vec4f(1.0, 1.0, 1.0, 1.0);

// Phong Light Model
// https://github.com/PacktPublishing/Real-Time-3D-Graphics-with-WebGL-2/blob/master/ch03/ch03_04_sphere-phong.html
fn light(normal: vec3f, materialDiffuse: vec4f, vertex: vec3f) -> vec4f {
  // Normalized light direction
  let L = normalize(uniforms.lightDirection.xyz);

  // Normalized normal
  let N = normalize(normal);

  let lambertTerm = dot(N, -L);
  if (lambertTerm > 0.0) {
    var Id = vec4f(uLightDiffuse * materialDiffuse * lambertTerm);
    return vec4f(Id.xyz, 1.0);
  } else {
    return vec4f(0.0, 0.0, 0.0, 1.0);
  }
}

fn randomGradient(p: vec2f) -> vec2f {
  let x = dot(p, vec2(123.4, 234.5));
  let y = dot(p, vec2(234.5, 345.6));
  var gradient = vec2(x, y);
  gradient = sin(gradient);
  gradient = gradient * 43758.5453;

  gradient = sin(gradient);
  return gradient;
}

fn quintic(p: vec2f) -> vec2f {
  return p * p * p * (10.0 + p * (-15.0 + p * 6.0));
}

// Perlin Noise
// https://github.com/SuboptimalEng/shader-tutorials/blob/main/05-perlin-noise/shader.frag
fn perlin(p: vec2f) -> f32 {
  // set up a grid of cells
  let gridId = floor(p);
  var gridUv = fract(p);

  // start by finding the coords of grid corners
  let bl = gridId + vec2f(0.0, 0.0);
  let br = gridId + vec2f(1.0, 0.0);
  let tl = gridId + vec2f(0.0, 1.0);
  let tr = gridId + vec2f(1.0, 1.0);

  // find random gradient for each grid corner
  let gradBl = randomGradient(bl);
  let gradBr = randomGradient(br);
  let gradTl = randomGradient(tl);
  let gradTr = randomGradient(tr);

  // find distance from current pixel to each grid corner
  let distFromPixelToBl = gridUv - vec2f(0.0, 0.0);
  let distFromPixelToBr = gridUv - vec2f(1.0, 0.0);
  let distFromPixelToTl = gridUv - vec2f(0.0, 1.0);
  let distFromPixelToTr = gridUv - vec2f(1.0, 1.0);

  // calculate the dot products of gradients + distances
  let dotBl = dot(gradBl, distFromPixelToBl);
  let dotBr = dot(gradBr, distFromPixelToBr);
  let dotTl = dot(gradTl, distFromPixelToTl);
  let dotTr = dot(gradTr, distFromPixelToTr);

  // smooth out gridUvs
  gridUv = quintic(gridUv);

  // perform linear interpolation between 4 dot products
  let b = mix(dotBl, dotBr, gridUv.x);
  let t = mix(dotTl, dotTr, gridUv.x);
  return mix(b, t, gridUv.y) / 2.0 + 0.5;
}

// Fractal Perlin Noise
fn terrainHeight(p: vec2f) -> f32 {
  var fractal = 0.0;
  var amplitude = 1.0;
  var pt = p;
  for (var i = 0; i < terrainFractalLayers; i++) {
    fractal += perlin(pt) * amplitude;
    pt *= 2.0;
    amplitude *= terrainAmplitudeFreq;
  }
  return fractal;
}

// Generate normal from perlin noise using derivatives
// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/perlin-noise-part-2/perlin-noise-computing-derivatives.html
fn terrainNormal(position: vec2f, noise_value: f32) -> vec3f {
  // point a bit to the right of the original value
  let position_offset_x = position.xy + vec2f(normalOffsetDelta, 0.0);
  // what is its noise value
  let noise_offset_x = terrainHeight(position_offset_x);
  // a vector from the point to the other one, using the noise result
  // as the third dimension
  let tangent_x = normalize(vec3f(position.xy, noise_value) - vec3f(position_offset_x, noise_offset_x));

  // same for Y
  let position_offset_y = position.xy + vec2f(0.0, normalOffsetDelta);
  let noise_offset_y = terrainHeight(position_offset_y);
  let tangent_y = normalize(vec3f(position.xy, noise_value) - vec3f(position_offset_y, noise_offset_y));

  // cross product of the two tangents of the point will create
  // the normal vector at that point
  return cross(tangent_x, tangent_y);
}

fn water(position: vec2f, t: f32) -> f32 {
  let x = position.x;
  let z = position.y;
  let scale = waveScale;
  let x_wave = (
    sin(x * 1.0 / scale + t * 1.0) +
    sin(x * 2.3 / scale + t * 1.5) +
    sin(x * 3.3 / scale + t * 0.4)
  ) / 3.0;
  let z_wave = (
    sin(z * 0.2 / scale + t * 1.8) +
    sin(z * 1.8 / scale + t * 1.8) +
    sin(z * 2.8 / scale + t * 0.8)
  ) / 3.0;
  return WATER_THRESHOLD + (x_wave + z_wave + 2.0) / 100.0;
}

fn waterNormal(position: vec2f, wave_value: f32, time: f32) -> vec3f {
  let position_offset_x = position.xy + vec2f(normalOffsetDelta, 0.0);
  let wave_offset_x = water(position_offset_x, time);
  let tangent_x = normalize(vec3f(position.xy, wave_value) - vec3f(position_offset_x, wave_offset_x));

  let position_offset_y = position.xy + vec2f(0.0, normalOffsetDelta);
  let wave_offset_y = water(position_offset_y, time);
  let tangent_y = normalize(vec3f(position.xy, wave_value) - vec3f(position_offset_y, wave_offset_y));

  return cross(tangent_x, tangent_y);
}

fn terrainColor(z: f32) -> vec4f {
  if(z < WATER_THRESHOLD) {
    return WATER_COLOR;
  } else if(z < SAND_THRESHOLD) {
    return mix(WATER_COLOR, SAND_COLOR, (z - WATER_THRESHOLD) / (SAND_THRESHOLD - WATER_THRESHOLD));
  } else if(z < GRASS_THRESHOLD) {
    return mix(SAND_COLOR, GRASS_COLOR, (z - SAND_THRESHOLD) / (GRASS_THRESHOLD - SAND_THRESHOLD));
  } else if(z < STONE_THRESHOLD) {
    return mix(GRASS_COLOR, STONE_COLOR, (z - GRASS_THRESHOLD) / (STONE_THRESHOLD - GRASS_THRESHOLD));
  } else {
    return mix(STONE_COLOR, SNOW_COLOR, (z - STONE_THRESHOLD) / (SNOW_THRESHOLD - STONE_THRESHOLD));
  }
}

@vertex
fn vertex_main(@location(0) position: vec4f) -> VertexOut {
  let time = uniforms.config.x;

  // Offset the position by the actual camera position to simulate the camera moving
  let offset_position = position.xz + uniforms.cameraPosition.xz;
  var terrain_value = terrainHeight(offset_position);
  var color = terrainColor(terrain_value);

  var normal = vec3f(0.0, 1.0, 0.0);
  if (terrain_value < WATER_THRESHOLD) {
    terrain_value = water(offset_position, time);
    normal = waterNormal(offset_position, terrain_value, time);
  } else {
    normal = terrainNormal(offset_position, terrain_value);
  }
  let terrain_position = vec4f(position.x, terrain_value, position.z, 1.0);

  var output = VertexOut();
  output.position = uniforms.projectionMatrix * uniforms.modelViewMatrix * terrain_position;
  output.color = color;
  output.normal = normal;
  // Fog depth is the distance from the camera to the vertex
  // https://webglfundamentals.org/webgl/lessons/webgl-fog.html
  output.fogDepth = -(uniforms.modelViewMatrix * terrain_position).z;
  return output;
}

@fragment
fn fragment_main(fragData: VertexOut) -> @location(0) vec4f {
  let fogOn = uniforms.config.y == 1.0;
  let lightsOn = uniforms.config.z == 1.0;
  let color_light = light(fragData.normal, fragData.color, fragData.position.xyz);
  var color = select(fragData.color, color_light, lightsOn);
  if (!fogOn) {
    return color;
  } else {
    let fogAmount = smoothstep(2.0, 8.0, fragData.fogDepth);
    return mix(color, vec4f(0.8, 0.9, 1.0, 1.0), fogAmount);  
  }
}`;class Ut{constructor(D,P=new Float32Array([0,1,0])){b(this,"viewMatrix");b(this,"position");b(this,"front",Bn.fromValues());b(this,"up",Bn.fromValues());b(this,"worldUp",Bn.fromValues());b(this,"right",Bn.fromValues());b(this,"yaw",-90);b(this,"pitch",-30);this.position=D,this.worldUp=P,this.viewMatrix=Kn.identity(),this.updateCameraVectors()}updateCameraVectors(){this.front=Bn.normalize(Bn.fromValues(Math.cos(Gn.degToRad(this.yaw))*Math.cos(Gn.degToRad(this.pitch)),Math.sin(Gn.degToRad(this.pitch)),Math.sin(Gn.degToRad(this.yaw))*Math.cos(Gn.degToRad(this.pitch)))),this.right=Bn.normalize(Bn.cross(this.front,this.worldUp)),this.up=Bn.normalize(Bn.cross(this.right,this.front))}processControls(D,P){const B=P;D.forwardKey&&(this.position=un.add(this.position,un.mul(this.front,un.fromValues(B,B,B)))),D.backwardKey&&(this.position=un.sub(this.position,un.mul(this.front,un.fromValues(B,B,B)))),D.leftKey&&(this.position=un.sub(this.position,un.mul(this.right,un.fromValues(B,B,B)))),D.rightKey&&(this.position=un.add(this.position,un.mul(this.right,un.fromValues(B,B,B))))}processMouseMovement(D,P){D*=.5,P*=.5,this.yaw+=D,this.pitch+=P,this.pitch>89?this.pitch=89:this.pitch<-89&&(this.pitch=-89),this.updateCameraVectors()}getViewMatrix(D=new Float32Array([this.position[0],this.position[2]])){const P=Bn.fromValues(D[0],this.position[1],D[2]);return Kn.lookAt(P,Bn.add(P,this.front),this.up)}}var Un;class Ft{constructor(){b(this,"projectionMatrix",Kn.create());b(this,"modelViewMatrix",Kn.create());b(this,"lightDirection",un.create());b(this,"fogColor",un.create());b(this,"cameraPosition",un.create());b(this,"config",un.create());b(this,"uniformBufferSize",this.projectionMatrix.byteLength+this.modelViewMatrix.byteLength+this.fogColor.byteLength+this.lightDirection.byteLength+this.cameraPosition.byteLength+this.config.byteLength);ct(this,Un,new Float32Array(this.uniformBufferSize/4));b(this,"getBufferData",()=>{const D=[this.projectionMatrix,this.modelViewMatrix,this.fogColor,this.lightDirection,this.cameraPosition,this.config];let P=0;for(let B=0;B<D.length;B++)Fn(this,Un).set(D[B],P),P+=D[B].byteLength/4;return{data:Fn(this,Un).buffer,dataOffset:Fn(this,Un).byteOffset,size:Fn(this,Un).byteLength}})}}Un=new WeakMap;class Gt{constructor(D,P){b(this,"forwardKey",!1);b(this,"backwardKey",!1);b(this,"leftKey",!1);b(this,"rightKey",!1);b(this,"fogOn",!0);b(this,"lightsOn",!0);document.addEventListener("keydown",W=>{const{key:N,altKey:C,ctrlKey:tn}=W;N==="w"?this.forwardKey=!0:N==="s"?this.backwardKey=!0:N==="a"?this.leftKey=!0:N==="d"&&(this.rightKey=!0),tn&&(this.fogOn=!this.fogOn),C&&(this.lightsOn=!this.lightsOn)}),document.addEventListener("keyup",W=>{const{key:N}=W;N==="w"?this.forwardKey=!1:N==="s"?this.backwardKey=!1:N==="a"?this.leftKey=!1:N==="d"?this.rightKey=!1:N==="Escape"&&D.removeEventListener("mousemove",B)});const B=W=>{P(W.movementX,-W.movementY)};D.addEventListener("click",()=>{D.requestPointerLock(),D.addEventListener("mousemove",B)})}}const Kt=.002,Wt=800,Nn=800,kn=8,wt=1/(Nn-1)*(kn*2),ht=un.fromValues(.8,.9,1,1),Jn=un.fromValues(0,3,0),$t=un.fromValues(-.25,-.25,-.25,0);let dt=performance.now();const jt=async()=>{if(!navigator.gpu)throw Error("WebGPU not supported.");const f=await navigator.gpu.requestAdapter();if(!f)throw Error("Couldn't request WebGPU adapter.");const D=await f.requestDevice(),P=document.querySelector("#gpuCanvas");P.width=window.innerWidth,P.height=window.innerHeight;const B=P.getContext("webgpu"),W=[];for(let Z=-8;Z<=kn;Z=Z+wt)for(let Q=-8;Q<=kn;Q=Q+wt)W.push(Z,0,Q);const N=new Float32Array(W),C=[];for(let Z=0;Z<=Nn-2;Z++)for(let Q=0;Q<=Nn-2;Q++){const an=Z*Nn+Q,nn=Z*Nn+Q+1,ln=(Z+1)*Nn+Q+1,G=(Z+1)*Nn+Q;C.push(an,nn,G),C.push(nn,G,ln)}const tn=new Uint32Array(C),vn=D.createShaderModule({code:Nt});B.configure({device:D,format:navigator.gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"});const En=D.createBuffer({label:"vertex buffer",size:N.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});D.queue.writeBuffer(En,0,N,0,N.length);const Pn={attributes:[{shaderLocation:0,offset:0,format:"float32x3"}],arrayStride:12,stepMode:"vertex"},fn=D.createBuffer({label:"index buffer",size:tn.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST});D.queue.writeBuffer(fn,0,tn);const en=new Ft,sn=D.createBuffer({label:"uniform buffer",size:en.uniformBufferSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),Rn={vertex:{module:vn,entryPoint:"vertex_main",buffers:[Pn]},fragment:{module:vn,entryPoint:"fragment_main",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]},primitive:{topology:"triangle-list"},layout:"auto"},hn=D.createRenderPipeline(Rn),Sn=D.createBindGroup({layout:hn.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:sn}}]}),qn=P.width/P.height,dn=Kn.perspective(2*Math.PI/5,qn,0,100),on=new Ut(Jn),zn=new Gt(P,(Z,Q)=>on.processMouseMovement(Z,Q));function On(Z){on.processControls(zn,Z);const Q=Bt.fromValues(Jn[0],Jn[2]);return on.getViewMatrix(Q)}function pn(){const Z=performance.now(),Q=Z-dt;dt=Z;const an=Z/Wt%1e3,nn=On(Q*Kt);en.projectionMatrix=dn,en.modelViewMatrix=nn,en.fogColor=ht,en.lightDirection=$t,en.cameraPosition=on.position,en.config=new Float32Array([an,zn.fogOn?1:0,zn.lightsOn?1:0]);const ln=en.getBufferData();D.queue.writeBuffer(sn,0,ln.data,ln.dataOffset,ln.size);const[G,J,K,a]=ht,O={colorAttachments:[{clearValue:{r:G,g:J,b:K,a},loadOp:"clear",storeOp:"store",view:B.getCurrentTexture().createView()}]},M=D.createCommandEncoder(),v=M.beginRenderPass(O);v.setPipeline(hn),v.setBindGroup(0,Sn),v.setVertexBuffer(0,En),v.setIndexBuffer(fn,"uint32"),v.drawIndexed(C.length),v.end(),D.queue.submit([M.finish()]),requestAnimationFrame(()=>pn())}pn()};jt();
