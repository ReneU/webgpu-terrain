var gt=Object.defineProperty;var ot=a=>{throw TypeError(a)};var Mt=(a,D,P)=>D in a?gt(a,D,{enumerable:!0,configurable:!0,writable:!0,value:P}):a[D]=P;var J=(a,D,P)=>Mt(a,typeof D!="symbol"?D+"":D,P),Dt=(a,D,P)=>D.has(a)||ot("Cannot "+P);var Un=(a,D,P)=>(Dt(a,D,"read from private field"),P?P.call(a):D.get(a)),ct=(a,D,P)=>D.has(a)?ot("Cannot add the same private member more than once"):D instanceof WeakSet?D.add(a):D.set(a,P);(function(){const D=document.createElement("link").relList;if(D&&D.supports&&D.supports("modulepreload"))return;for(const W of document.querySelectorAll('link[rel="modulepreload"]'))B(W);new MutationObserver(W=>{for(const Z of W)if(Z.type==="childList")for(const nn of Z.addedNodes)nn.tagName==="LINK"&&nn.rel==="modulepreload"&&B(nn)}).observe(document,{childList:!0,subtree:!0});function P(W){const Z={};return W.integrity&&(Z.integrity=W.integrity),W.referrerPolicy&&(Z.referrerPolicy=W.referrerPolicy),W.crossOrigin==="use-credentials"?Z.credentials="include":W.crossOrigin==="anonymous"?Z.credentials="omit":Z.credentials="same-origin",Z}function B(W){if(W.ep)return;W.ep=!0;const Z=P(W);fetch(W.href,Z)}})();function xt(a,D){return class extends a{constructor(...P){super(...P),D(this)}}}const yt=xt(Array,a=>a.fill(0));let I=1e-6;function _t(a){const D=I;return I=a,D}function vt(a){return a*Math.PI/180}function St(a){return a*180/Math.PI}function Ot(a,D,P){return a+(D-a)*P}function zt(a,D,P){const B=D-a;return Math.abs(D-a)<I?a:(P-a)/B}function At(a,D){return(a%D+D)%D}var Gn={__proto__:null,get EPSILON(){return I},degToRad:vt,euclideanModulo:At,inverseLerp:zt,lerp:Ot,radToDeg:St,setEpsilon:_t};function mt(a){function D(n=0,o=0){const t=new a(2);return n!==void 0&&(t[0]=n,o!==void 0&&(t[1]=o)),t}const P=D;function B(n,o,t){const e=t??new a(2);return e[0]=n,e[1]=o,e}function W(n,o){const t=o??new a(2);return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t}function Z(n,o){const t=o??new a(2);return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t}function nn(n,o){const t=o??new a(2);return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t}function un(n,o=0,t=1,e){const u=e??new a(2);return u[0]=Math.min(t,Math.max(o,n[0])),u[1]=Math.min(t,Math.max(o,n[1])),u}function Sn(n,o,t){const e=t??new a(2);return e[0]=n[0]+o[0],e[1]=n[1]+o[1],e}function En(n,o,t,e){const u=e??new a(2);return u[0]=n[0]+o[0]*t,u[1]=n[1]+o[1]*t,u}function Pn(n,o){const t=n[0],e=n[1],u=o[0],p=o[1],_=Math.sqrt(t*t+e*e),s=Math.sqrt(u*u+p*p),i=_*s,w=i&&fn(n,o)/i;return Math.acos(w)}function an(n,o,t){const e=t??new a(2);return e[0]=n[0]-o[0],e[1]=n[1]-o[1],e}const tn=an;function sn(n,o){return Math.abs(n[0]-o[0])<I&&Math.abs(n[1]-o[1])<I}function Rn(n,o){return n[0]===o[0]&&n[1]===o[1]}function hn(n,o,t,e){const u=e??new a(2);return u[0]=n[0]+t*(o[0]-n[0]),u[1]=n[1]+t*(o[1]-n[1]),u}function On(n,o,t,e){const u=e??new a(2);return u[0]=n[0]+t[0]*(o[0]-n[0]),u[1]=n[1]+t[1]*(o[1]-n[1]),u}function qn(n,o,t){const e=t??new a(2);return e[0]=Math.max(n[0],o[0]),e[1]=Math.max(n[1],o[1]),e}function dn(n,o,t){const e=t??new a(2);return e[0]=Math.min(n[0],o[0]),e[1]=Math.min(n[1],o[1]),e}function en(n,o,t){const e=t??new a(2);return e[0]=n[0]*o,e[1]=n[1]*o,e}const pn=en;function zn(n,o,t){const e=t??new a(2);return e[0]=n[0]/o,e[1]=n[1]/o,e}function gn(n,o){const t=o??new a(2);return t[0]=1/n[0],t[1]=1/n[1],t}const Y=gn;function X(n,o,t){const e=t??new a(3),u=n[0]*o[1]-n[1]*o[0];return e[0]=0,e[1]=0,e[2]=u,e}function fn(n,o){return n[0]*o[0]+n[1]*o[1]}function C(n){const o=n[0],t=n[1];return Math.sqrt(o*o+t*t)}const ln=C;function U(n){const o=n[0],t=n[1];return o*o+t*t}const Q=U;function G(n,o){const t=n[0]-o[0],e=n[1]-o[1];return Math.sqrt(t*t+e*e)}const f=G;function z(n,o){const t=n[0]-o[0],e=n[1]-o[1];return t*t+e*e}const M=z;function v(n,o){const t=o??new a(2),e=n[0],u=n[1],p=Math.sqrt(e*e+u*u);return p>1e-5?(t[0]=e/p,t[1]=u/p):(t[0]=0,t[1]=0),t}function E(n,o){const t=o??new a(2);return t[0]=-n[0],t[1]=-n[1],t}function m(n,o){const t=o??new a(2);return t[0]=n[0],t[1]=n[1],t}const N=m;function F(n,o,t){const e=t??new a(2);return e[0]=n[0]*o[0],e[1]=n[1]*o[1],e}const $=F;function q(n,o,t){const e=t??new a(2);return e[0]=n[0]/o[0],e[1]=n[1]/o[1],e}const H=q;function k(n=1,o){const t=o??new a(2),e=Math.random()*2*Math.PI;return t[0]=Math.cos(e)*n,t[1]=Math.sin(e)*n,t}function g(n){const o=n??new a(2);return o[0]=0,o[1]=0,o}function O(n,o,t){const e=t??new a(2),u=n[0],p=n[1];return e[0]=u*o[0]+p*o[4]+o[12],e[1]=u*o[1]+p*o[5]+o[13],e}function c(n,o,t){const e=t??new a(2),u=n[0],p=n[1];return e[0]=o[0]*u+o[4]*p+o[8],e[1]=o[1]*u+o[5]*p+o[9],e}function r(n,o,t,e){const u=e??new a(2),p=n[0]-o[0],_=n[1]-o[1],s=Math.sin(t),i=Math.cos(t);return u[0]=p*i-_*s+o[0],u[1]=p*s+_*i+o[1],u}function l(n,o,t){const e=t??new a(2);return v(n,e),en(e,o,e)}function d(n,o,t){const e=t??new a(2);return C(n)>o?l(n,o,e):m(n,e)}function A(n,o,t){const e=t??new a(2);return hn(n,o,.5,e)}return{create:D,fromValues:P,set:B,ceil:W,floor:Z,round:nn,clamp:un,add:Sn,addScaled:En,angle:Pn,subtract:an,sub:tn,equalsApproximately:sn,equals:Rn,lerp:hn,lerpV:On,max:qn,min:dn,mulScalar:en,scale:pn,divScalar:zn,inverse:gn,invert:Y,cross:X,dot:fn,length:C,len:ln,lengthSq:U,lenSq:Q,distance:G,dist:f,distanceSq:z,distSq:M,normalize:v,negate:E,copy:m,clone:N,multiply:F,mul:$,divide:q,div:H,random:k,zero:g,transformMat4:O,transformMat3:c,rotate:r,setLength:l,truncate:d,midpoint:A}}const rt=new Map;function pt(a){let D=rt.get(a);return D||(D=mt(a),rt.set(a,D)),D}function Tt(a){const D=pt(a);function P(f,z,M,v,E,m,N,F,$){const q=new a(12);return q[3]=0,q[7]=0,q[11]=0,f!==void 0&&(q[0]=f,z!==void 0&&(q[1]=z,M!==void 0&&(q[2]=M,v!==void 0&&(q[4]=v,E!==void 0&&(q[5]=E,m!==void 0&&(q[6]=m,N!==void 0&&(q[8]=N,F!==void 0&&(q[9]=F,$!==void 0&&(q[10]=$))))))))),q}function B(f,z,M,v,E,m,N,F,$,q){const H=q??new a(12);return H[0]=f,H[1]=z,H[2]=M,H[3]=0,H[4]=v,H[5]=E,H[6]=m,H[7]=0,H[8]=N,H[9]=F,H[10]=$,H[11]=0,H}function W(f,z){const M=z??new a(12);return M[0]=f[0],M[1]=f[1],M[2]=f[2],M[3]=0,M[4]=f[4],M[5]=f[5],M[6]=f[6],M[7]=0,M[8]=f[8],M[9]=f[9],M[10]=f[10],M[11]=0,M}function Z(f,z){const M=z??new a(12),v=f[0],E=f[1],m=f[2],N=f[3],F=v+v,$=E+E,q=m+m,H=v*F,k=E*F,g=E*$,O=m*F,c=m*$,r=m*q,l=N*F,d=N*$,A=N*q;return M[0]=1-g-r,M[1]=k+A,M[2]=O-d,M[3]=0,M[4]=k-A,M[5]=1-H-r,M[6]=c+l,M[7]=0,M[8]=O+d,M[9]=c-l,M[10]=1-H-g,M[11]=0,M}function nn(f,z){const M=z??new a(12);return M[0]=-f[0],M[1]=-f[1],M[2]=-f[2],M[4]=-f[4],M[5]=-f[5],M[6]=-f[6],M[8]=-f[8],M[9]=-f[9],M[10]=-f[10],M}function un(f,z){const M=z??new a(12);return M[0]=f[0],M[1]=f[1],M[2]=f[2],M[4]=f[4],M[5]=f[5],M[6]=f[6],M[8]=f[8],M[9]=f[9],M[10]=f[10],M}const Sn=un;function En(f,z){return Math.abs(f[0]-z[0])<I&&Math.abs(f[1]-z[1])<I&&Math.abs(f[2]-z[2])<I&&Math.abs(f[4]-z[4])<I&&Math.abs(f[5]-z[5])<I&&Math.abs(f[6]-z[6])<I&&Math.abs(f[8]-z[8])<I&&Math.abs(f[9]-z[9])<I&&Math.abs(f[10]-z[10])<I}function Pn(f,z){return f[0]===z[0]&&f[1]===z[1]&&f[2]===z[2]&&f[4]===z[4]&&f[5]===z[5]&&f[6]===z[6]&&f[8]===z[8]&&f[9]===z[9]&&f[10]===z[10]}function an(f){const z=f??new a(12);return z[0]=1,z[1]=0,z[2]=0,z[4]=0,z[5]=1,z[6]=0,z[8]=0,z[9]=0,z[10]=1,z}function tn(f,z){const M=z??new a(12);if(M===f){let g;return g=f[1],f[1]=f[4],f[4]=g,g=f[2],f[2]=f[8],f[8]=g,g=f[6],f[6]=f[9],f[9]=g,M}const v=f[0*4+0],E=f[0*4+1],m=f[0*4+2],N=f[1*4+0],F=f[1*4+1],$=f[1*4+2],q=f[2*4+0],H=f[2*4+1],k=f[2*4+2];return M[0]=v,M[1]=N,M[2]=q,M[4]=E,M[5]=F,M[6]=H,M[8]=m,M[9]=$,M[10]=k,M}function sn(f,z){const M=z??new a(12),v=f[0*4+0],E=f[0*4+1],m=f[0*4+2],N=f[1*4+0],F=f[1*4+1],$=f[1*4+2],q=f[2*4+0],H=f[2*4+1],k=f[2*4+2],g=k*F-$*H,O=-k*N+$*q,c=H*N-F*q,r=1/(v*g+E*O+m*c);return M[0]=g*r,M[1]=(-k*E+m*H)*r,M[2]=($*E-m*F)*r,M[4]=O*r,M[5]=(k*v-m*q)*r,M[6]=(-$*v+m*N)*r,M[8]=c*r,M[9]=(-H*v+E*q)*r,M[10]=(F*v-E*N)*r,M}function Rn(f){const z=f[0],M=f[0*4+1],v=f[0*4+2],E=f[1*4+0],m=f[1*4+1],N=f[1*4+2],F=f[2*4+0],$=f[2*4+1],q=f[2*4+2];return z*(m*q-$*N)-E*(M*q-$*v)+F*(M*N-m*v)}const hn=sn;function On(f,z,M){const v=M??new a(12),E=f[0],m=f[1],N=f[2],F=f[4],$=f[5],q=f[6],H=f[8],k=f[9],g=f[10],O=z[0],c=z[1],r=z[2],l=z[4],d=z[5],A=z[6],n=z[8],o=z[9],t=z[10];return v[0]=E*O+F*c+H*r,v[1]=m*O+$*c+k*r,v[2]=N*O+q*c+g*r,v[4]=E*l+F*d+H*A,v[5]=m*l+$*d+k*A,v[6]=N*l+q*d+g*A,v[8]=E*n+F*o+H*t,v[9]=m*n+$*o+k*t,v[10]=N*n+q*o+g*t,v}const qn=On;function dn(f,z,M){const v=M??an();return f!==v&&(v[0]=f[0],v[1]=f[1],v[2]=f[2],v[4]=f[4],v[5]=f[5],v[6]=f[6]),v[8]=z[0],v[9]=z[1],v[10]=1,v}function en(f,z){const M=z??D.create();return M[0]=f[8],M[1]=f[9],M}function pn(f,z,M){const v=M??D.create(),E=z*4;return v[0]=f[E+0],v[1]=f[E+1],v}function zn(f,z,M,v){const E=v===f?f:un(f,v),m=M*4;return E[m+0]=z[0],E[m+1]=z[1],E}function gn(f,z){const M=z??D.create(),v=f[0],E=f[1],m=f[4],N=f[5];return M[0]=Math.sqrt(v*v+E*E),M[1]=Math.sqrt(m*m+N*N),M}function Y(f,z){const M=z??new a(12);return M[0]=1,M[1]=0,M[2]=0,M[4]=0,M[5]=1,M[6]=0,M[8]=f[0],M[9]=f[1],M[10]=1,M}function X(f,z,M){const v=M??new a(12),E=z[0],m=z[1],N=f[0],F=f[1],$=f[2],q=f[1*4+0],H=f[1*4+1],k=f[1*4+2],g=f[2*4+0],O=f[2*4+1],c=f[2*4+2];return f!==v&&(v[0]=N,v[1]=F,v[2]=$,v[4]=q,v[5]=H,v[6]=k),v[8]=N*E+q*m+g,v[9]=F*E+H*m+O,v[10]=$*E+k*m+c,v}function fn(f,z){const M=z??new a(12),v=Math.cos(f),E=Math.sin(f);return M[0]=v,M[1]=E,M[2]=0,M[4]=-E,M[5]=v,M[6]=0,M[8]=0,M[9]=0,M[10]=1,M}function C(f,z,M){const v=M??new a(12),E=f[0*4+0],m=f[0*4+1],N=f[0*4+2],F=f[1*4+0],$=f[1*4+1],q=f[1*4+2],H=Math.cos(z),k=Math.sin(z);return v[0]=H*E+k*F,v[1]=H*m+k*$,v[2]=H*N+k*q,v[4]=H*F-k*E,v[5]=H*$-k*m,v[6]=H*q-k*N,f!==v&&(v[8]=f[8],v[9]=f[9],v[10]=f[10]),v}function ln(f,z){const M=z??new a(12);return M[0]=f[0],M[1]=0,M[2]=0,M[4]=0,M[5]=f[1],M[6]=0,M[8]=0,M[9]=0,M[10]=1,M}function U(f,z,M){const v=M??new a(12),E=z[0],m=z[1];return v[0]=E*f[0*4+0],v[1]=E*f[0*4+1],v[2]=E*f[0*4+2],v[4]=m*f[1*4+0],v[5]=m*f[1*4+1],v[6]=m*f[1*4+2],f!==v&&(v[8]=f[8],v[9]=f[9],v[10]=f[10]),v}function Q(f,z){const M=z??new a(12);return M[0]=f,M[1]=0,M[2]=0,M[4]=0,M[5]=f,M[6]=0,M[8]=0,M[9]=0,M[10]=1,M}function G(f,z,M){const v=M??new a(12);return v[0]=z*f[0*4+0],v[1]=z*f[0*4+1],v[2]=z*f[0*4+2],v[4]=z*f[1*4+0],v[5]=z*f[1*4+1],v[6]=z*f[1*4+2],f!==v&&(v[8]=f[8],v[9]=f[9],v[10]=f[10]),v}return{clone:Sn,create:P,set:B,fromMat4:W,fromQuat:Z,negate:nn,copy:un,equalsApproximately:En,equals:Pn,identity:an,transpose:tn,inverse:sn,invert:hn,determinant:Rn,mul:qn,multiply:On,setTranslation:dn,getTranslation:en,getAxis:pn,setAxis:zn,getScaling:gn,translation:Y,translate:X,rotation:fn,rotate:C,scaling:ln,scale:U,uniformScaling:Q,uniformScale:G}}const it=new Map;function Lt(a){let D=it.get(a);return D||(D=Tt(a),it.set(a,D)),D}function Et(a){function D(s,i,w){const h=new a(3);return s!==void 0&&(h[0]=s,i!==void 0&&(h[1]=i,w!==void 0&&(h[2]=w))),h}const P=D;function B(s,i,w,h){const x=h??new a(3);return x[0]=s,x[1]=i,x[2]=w,x}function W(s,i){const w=i??new a(3);return w[0]=Math.ceil(s[0]),w[1]=Math.ceil(s[1]),w[2]=Math.ceil(s[2]),w}function Z(s,i){const w=i??new a(3);return w[0]=Math.floor(s[0]),w[1]=Math.floor(s[1]),w[2]=Math.floor(s[2]),w}function nn(s,i){const w=i??new a(3);return w[0]=Math.round(s[0]),w[1]=Math.round(s[1]),w[2]=Math.round(s[2]),w}function un(s,i=0,w=1,h){const x=h??new a(3);return x[0]=Math.min(w,Math.max(i,s[0])),x[1]=Math.min(w,Math.max(i,s[1])),x[2]=Math.min(w,Math.max(i,s[2])),x}function Sn(s,i,w){const h=w??new a(3);return h[0]=s[0]+i[0],h[1]=s[1]+i[1],h[2]=s[2]+i[2],h}function En(s,i,w,h){const x=h??new a(3);return x[0]=s[0]+i[0]*w,x[1]=s[1]+i[1]*w,x[2]=s[2]+i[2]*w,x}function Pn(s,i){const w=s[0],h=s[1],x=s[2],y=i[0],S=i[1],R=i[2],V=Math.sqrt(w*w+h*h+x*x),T=Math.sqrt(y*y+S*S+R*R),L=V*T,K=L&&fn(s,i)/L;return Math.acos(K)}function an(s,i,w){const h=w??new a(3);return h[0]=s[0]-i[0],h[1]=s[1]-i[1],h[2]=s[2]-i[2],h}const tn=an;function sn(s,i){return Math.abs(s[0]-i[0])<I&&Math.abs(s[1]-i[1])<I&&Math.abs(s[2]-i[2])<I}function Rn(s,i){return s[0]===i[0]&&s[1]===i[1]&&s[2]===i[2]}function hn(s,i,w,h){const x=h??new a(3);return x[0]=s[0]+w*(i[0]-s[0]),x[1]=s[1]+w*(i[1]-s[1]),x[2]=s[2]+w*(i[2]-s[2]),x}function On(s,i,w,h){const x=h??new a(3);return x[0]=s[0]+w[0]*(i[0]-s[0]),x[1]=s[1]+w[1]*(i[1]-s[1]),x[2]=s[2]+w[2]*(i[2]-s[2]),x}function qn(s,i,w){const h=w??new a(3);return h[0]=Math.max(s[0],i[0]),h[1]=Math.max(s[1],i[1]),h[2]=Math.max(s[2],i[2]),h}function dn(s,i,w){const h=w??new a(3);return h[0]=Math.min(s[0],i[0]),h[1]=Math.min(s[1],i[1]),h[2]=Math.min(s[2],i[2]),h}function en(s,i,w){const h=w??new a(3);return h[0]=s[0]*i,h[1]=s[1]*i,h[2]=s[2]*i,h}const pn=en;function zn(s,i,w){const h=w??new a(3);return h[0]=s[0]/i,h[1]=s[1]/i,h[2]=s[2]/i,h}function gn(s,i){const w=i??new a(3);return w[0]=1/s[0],w[1]=1/s[1],w[2]=1/s[2],w}const Y=gn;function X(s,i,w){const h=w??new a(3),x=s[2]*i[0]-s[0]*i[2],y=s[0]*i[1]-s[1]*i[0];return h[0]=s[1]*i[2]-s[2]*i[1],h[1]=x,h[2]=y,h}function fn(s,i){return s[0]*i[0]+s[1]*i[1]+s[2]*i[2]}function C(s){const i=s[0],w=s[1],h=s[2];return Math.sqrt(i*i+w*w+h*h)}const ln=C;function U(s){const i=s[0],w=s[1],h=s[2];return i*i+w*w+h*h}const Q=U;function G(s,i){const w=s[0]-i[0],h=s[1]-i[1],x=s[2]-i[2];return Math.sqrt(w*w+h*h+x*x)}const f=G;function z(s,i){const w=s[0]-i[0],h=s[1]-i[1],x=s[2]-i[2];return w*w+h*h+x*x}const M=z;function v(s,i){const w=i??new a(3),h=s[0],x=s[1],y=s[2],S=Math.sqrt(h*h+x*x+y*y);return S>1e-5?(w[0]=h/S,w[1]=x/S,w[2]=y/S):(w[0]=0,w[1]=0,w[2]=0),w}function E(s,i){const w=i??new a(3);return w[0]=-s[0],w[1]=-s[1],w[2]=-s[2],w}function m(s,i){const w=i??new a(3);return w[0]=s[0],w[1]=s[1],w[2]=s[2],w}const N=m;function F(s,i,w){const h=w??new a(3);return h[0]=s[0]*i[0],h[1]=s[1]*i[1],h[2]=s[2]*i[2],h}const $=F;function q(s,i,w){const h=w??new a(3);return h[0]=s[0]/i[0],h[1]=s[1]/i[1],h[2]=s[2]/i[2],h}const H=q;function k(s=1,i){const w=i??new a(3),h=Math.random()*2*Math.PI,x=Math.random()*2-1,y=Math.sqrt(1-x*x)*s;return w[0]=Math.cos(h)*y,w[1]=Math.sin(h)*y,w[2]=x*s,w}function g(s){const i=s??new a(3);return i[0]=0,i[1]=0,i[2]=0,i}function O(s,i,w){const h=w??new a(3),x=s[0],y=s[1],S=s[2],R=i[3]*x+i[7]*y+i[11]*S+i[15]||1;return h[0]=(i[0]*x+i[4]*y+i[8]*S+i[12])/R,h[1]=(i[1]*x+i[5]*y+i[9]*S+i[13])/R,h[2]=(i[2]*x+i[6]*y+i[10]*S+i[14])/R,h}function c(s,i,w){const h=w??new a(3),x=s[0],y=s[1],S=s[2];return h[0]=x*i[0*4+0]+y*i[1*4+0]+S*i[2*4+0],h[1]=x*i[0*4+1]+y*i[1*4+1]+S*i[2*4+1],h[2]=x*i[0*4+2]+y*i[1*4+2]+S*i[2*4+2],h}function r(s,i,w){const h=w??new a(3),x=s[0],y=s[1],S=s[2];return h[0]=x*i[0]+y*i[4]+S*i[8],h[1]=x*i[1]+y*i[5]+S*i[9],h[2]=x*i[2]+y*i[6]+S*i[10],h}function l(s,i,w){const h=w??new a(3),x=i[0],y=i[1],S=i[2],R=i[3]*2,V=s[0],T=s[1],L=s[2],K=y*L-S*T,j=S*V-x*L,b=x*T-y*V;return h[0]=V+K*R+(y*b-S*j)*2,h[1]=T+j*R+(S*K-x*b)*2,h[2]=L+b*R+(x*j-y*K)*2,h}function d(s,i){const w=i??new a(3);return w[0]=s[12],w[1]=s[13],w[2]=s[14],w}function A(s,i,w){const h=w??new a(3),x=i*4;return h[0]=s[x+0],h[1]=s[x+1],h[2]=s[x+2],h}function n(s,i){const w=i??new a(3),h=s[0],x=s[1],y=s[2],S=s[4],R=s[5],V=s[6],T=s[8],L=s[9],K=s[10];return w[0]=Math.sqrt(h*h+x*x+y*y),w[1]=Math.sqrt(S*S+R*R+V*V),w[2]=Math.sqrt(T*T+L*L+K*K),w}function o(s,i,w,h){const x=h??new a(3),y=[],S=[];return y[0]=s[0]-i[0],y[1]=s[1]-i[1],y[2]=s[2]-i[2],S[0]=y[0],S[1]=y[1]*Math.cos(w)-y[2]*Math.sin(w),S[2]=y[1]*Math.sin(w)+y[2]*Math.cos(w),x[0]=S[0]+i[0],x[1]=S[1]+i[1],x[2]=S[2]+i[2],x}function t(s,i,w,h){const x=h??new a(3),y=[],S=[];return y[0]=s[0]-i[0],y[1]=s[1]-i[1],y[2]=s[2]-i[2],S[0]=y[2]*Math.sin(w)+y[0]*Math.cos(w),S[1]=y[1],S[2]=y[2]*Math.cos(w)-y[0]*Math.sin(w),x[0]=S[0]+i[0],x[1]=S[1]+i[1],x[2]=S[2]+i[2],x}function e(s,i,w,h){const x=h??new a(3),y=[],S=[];return y[0]=s[0]-i[0],y[1]=s[1]-i[1],y[2]=s[2]-i[2],S[0]=y[0]*Math.cos(w)-y[1]*Math.sin(w),S[1]=y[0]*Math.sin(w)+y[1]*Math.cos(w),S[2]=y[2],x[0]=S[0]+i[0],x[1]=S[1]+i[1],x[2]=S[2]+i[2],x}function u(s,i,w){const h=w??new a(3);return v(s,h),en(h,i,h)}function p(s,i,w){const h=w??new a(3);return C(s)>i?u(s,i,h):m(s,h)}function _(s,i,w){const h=w??new a(3);return hn(s,i,.5,h)}return{create:D,fromValues:P,set:B,ceil:W,floor:Z,round:nn,clamp:un,add:Sn,addScaled:En,angle:Pn,subtract:an,sub:tn,equalsApproximately:sn,equals:Rn,lerp:hn,lerpV:On,max:qn,min:dn,mulScalar:en,scale:pn,divScalar:zn,inverse:gn,invert:Y,cross:X,dot:fn,length:C,len:ln,lengthSq:U,lenSq:Q,distance:G,dist:f,distanceSq:z,distSq:M,normalize:v,negate:E,copy:m,clone:N,multiply:F,mul:$,divide:q,div:H,random:k,zero:g,transformMat4:O,transformMat4Upper3x3:c,transformMat3:r,transformQuat:l,getTranslation:d,getAxis:A,getScaling:n,rotateX:o,rotateY:t,rotateZ:e,setLength:u,truncate:p,midpoint:_}}const ut=new Map;function bn(a){let D=ut.get(a);return D||(D=Et(a),ut.set(a,D)),D}function Pt(a){const D=bn(a);function P(n,o,t,e,u,p,_,s,i,w,h,x,y,S,R,V){const T=new a(16);return n!==void 0&&(T[0]=n,o!==void 0&&(T[1]=o,t!==void 0&&(T[2]=t,e!==void 0&&(T[3]=e,u!==void 0&&(T[4]=u,p!==void 0&&(T[5]=p,_!==void 0&&(T[6]=_,s!==void 0&&(T[7]=s,i!==void 0&&(T[8]=i,w!==void 0&&(T[9]=w,h!==void 0&&(T[10]=h,x!==void 0&&(T[11]=x,y!==void 0&&(T[12]=y,S!==void 0&&(T[13]=S,R!==void 0&&(T[14]=R,V!==void 0&&(T[15]=V)))))))))))))))),T}function B(n,o,t,e,u,p,_,s,i,w,h,x,y,S,R,V,T){const L=T??new a(16);return L[0]=n,L[1]=o,L[2]=t,L[3]=e,L[4]=u,L[5]=p,L[6]=_,L[7]=s,L[8]=i,L[9]=w,L[10]=h,L[11]=x,L[12]=y,L[13]=S,L[14]=R,L[15]=V,L}function W(n,o){const t=o??new a(16);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=0,t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=0,t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function Z(n,o){const t=o??new a(16),e=n[0],u=n[1],p=n[2],_=n[3],s=e+e,i=u+u,w=p+p,h=e*s,x=u*s,y=u*i,S=p*s,R=p*i,V=p*w,T=_*s,L=_*i,K=_*w;return t[0]=1-y-V,t[1]=x+K,t[2]=S-L,t[3]=0,t[4]=x-K,t[5]=1-h-V,t[6]=R+T,t[7]=0,t[8]=S+L,t[9]=R-T,t[10]=1-h-y,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function nn(n,o){const t=o??new a(16);return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t[4]=-n[4],t[5]=-n[5],t[6]=-n[6],t[7]=-n[7],t[8]=-n[8],t[9]=-n[9],t[10]=-n[10],t[11]=-n[11],t[12]=-n[12],t[13]=-n[13],t[14]=-n[14],t[15]=-n[15],t}function un(n,o){const t=o??new a(16);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t}const Sn=un;function En(n,o){return Math.abs(n[0]-o[0])<I&&Math.abs(n[1]-o[1])<I&&Math.abs(n[2]-o[2])<I&&Math.abs(n[3]-o[3])<I&&Math.abs(n[4]-o[4])<I&&Math.abs(n[5]-o[5])<I&&Math.abs(n[6]-o[6])<I&&Math.abs(n[7]-o[7])<I&&Math.abs(n[8]-o[8])<I&&Math.abs(n[9]-o[9])<I&&Math.abs(n[10]-o[10])<I&&Math.abs(n[11]-o[11])<I&&Math.abs(n[12]-o[12])<I&&Math.abs(n[13]-o[13])<I&&Math.abs(n[14]-o[14])<I&&Math.abs(n[15]-o[15])<I}function Pn(n,o){return n[0]===o[0]&&n[1]===o[1]&&n[2]===o[2]&&n[3]===o[3]&&n[4]===o[4]&&n[5]===o[5]&&n[6]===o[6]&&n[7]===o[7]&&n[8]===o[8]&&n[9]===o[9]&&n[10]===o[10]&&n[11]===o[11]&&n[12]===o[12]&&n[13]===o[13]&&n[14]===o[14]&&n[15]===o[15]}function an(n){const o=n??new a(16);return o[0]=1,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=1,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1,o[11]=0,o[12]=0,o[13]=0,o[14]=0,o[15]=1,o}function tn(n,o){const t=o??new a(16);if(t===n){let j;return j=n[1],n[1]=n[4],n[4]=j,j=n[2],n[2]=n[8],n[8]=j,j=n[3],n[3]=n[12],n[12]=j,j=n[6],n[6]=n[9],n[9]=j,j=n[7],n[7]=n[13],n[13]=j,j=n[11],n[11]=n[14],n[14]=j,t}const e=n[0*4+0],u=n[0*4+1],p=n[0*4+2],_=n[0*4+3],s=n[1*4+0],i=n[1*4+1],w=n[1*4+2],h=n[1*4+3],x=n[2*4+0],y=n[2*4+1],S=n[2*4+2],R=n[2*4+3],V=n[3*4+0],T=n[3*4+1],L=n[3*4+2],K=n[3*4+3];return t[0]=e,t[1]=s,t[2]=x,t[3]=V,t[4]=u,t[5]=i,t[6]=y,t[7]=T,t[8]=p,t[9]=w,t[10]=S,t[11]=L,t[12]=_,t[13]=h,t[14]=R,t[15]=K,t}function sn(n,o){const t=o??new a(16),e=n[0*4+0],u=n[0*4+1],p=n[0*4+2],_=n[0*4+3],s=n[1*4+0],i=n[1*4+1],w=n[1*4+2],h=n[1*4+3],x=n[2*4+0],y=n[2*4+1],S=n[2*4+2],R=n[2*4+3],V=n[3*4+0],T=n[3*4+1],L=n[3*4+2],K=n[3*4+3],j=S*K,b=L*R,on=w*K,cn=L*h,wn=w*R,Mn=S*h,Dn=p*K,xn=L*_,yn=p*R,_n=S*_,An=p*h,mn=w*_,Tn=x*T,Ln=V*y,Hn=s*T,Vn=V*i,In=s*y,Kn=x*i,$n=e*T,jn=V*u,kn=e*y,Yn=x*u,Xn=e*i,Zn=s*u,nt=j*i+cn*y+wn*T-(b*i+on*y+Mn*T),tt=b*u+Dn*y+_n*T-(j*u+xn*y+yn*T),et=on*u+xn*i+An*T-(cn*u+Dn*i+mn*T),st=Mn*u+yn*i+mn*y-(wn*u+_n*i+An*y),vn=1/(e*nt+s*tt+x*et+V*st);return t[0]=vn*nt,t[1]=vn*tt,t[2]=vn*et,t[3]=vn*st,t[4]=vn*(b*s+on*x+Mn*V-(j*s+cn*x+wn*V)),t[5]=vn*(j*e+xn*x+yn*V-(b*e+Dn*x+_n*V)),t[6]=vn*(cn*e+Dn*s+mn*V-(on*e+xn*s+An*V)),t[7]=vn*(wn*e+_n*s+An*x-(Mn*e+yn*s+mn*x)),t[8]=vn*(Tn*h+Vn*R+In*K-(Ln*h+Hn*R+Kn*K)),t[9]=vn*(Ln*_+$n*R+Yn*K-(Tn*_+jn*R+kn*K)),t[10]=vn*(Hn*_+jn*h+Xn*K-(Vn*_+$n*h+Zn*K)),t[11]=vn*(Kn*_+kn*h+Zn*R-(In*_+Yn*h+Xn*R)),t[12]=vn*(Hn*S+Kn*L+Ln*w-(In*L+Tn*w+Vn*S)),t[13]=vn*(kn*L+Tn*p+jn*S-($n*S+Yn*L+Ln*p)),t[14]=vn*($n*w+Zn*L+Vn*p-(Xn*L+Hn*p+jn*w)),t[15]=vn*(Xn*S+In*p+Yn*w-(kn*w+Zn*S+Kn*p)),t}function Rn(n){const o=n[0],t=n[0*4+1],e=n[0*4+2],u=n[0*4+3],p=n[1*4+0],_=n[1*4+1],s=n[1*4+2],i=n[1*4+3],w=n[2*4+0],h=n[2*4+1],x=n[2*4+2],y=n[2*4+3],S=n[3*4+0],R=n[3*4+1],V=n[3*4+2],T=n[3*4+3],L=x*T,K=V*y,j=s*T,b=V*i,on=s*y,cn=x*i,wn=e*T,Mn=V*u,Dn=e*y,xn=x*u,yn=e*i,_n=s*u,An=L*_+b*h+on*R-(K*_+j*h+cn*R),mn=K*t+wn*h+xn*R-(L*t+Mn*h+Dn*R),Tn=j*t+Mn*_+yn*R-(b*t+wn*_+_n*R),Ln=cn*t+Dn*_+_n*h-(on*t+xn*_+yn*h);return o*An+p*mn+w*Tn+S*Ln}const hn=sn;function On(n,o,t){const e=t??new a(16),u=n[0],p=n[1],_=n[2],s=n[3],i=n[4],w=n[5],h=n[6],x=n[7],y=n[8],S=n[9],R=n[10],V=n[11],T=n[12],L=n[13],K=n[14],j=n[15],b=o[0],on=o[1],cn=o[2],wn=o[3],Mn=o[4],Dn=o[5],xn=o[6],yn=o[7],_n=o[8],An=o[9],mn=o[10],Tn=o[11],Ln=o[12],Hn=o[13],Vn=o[14],In=o[15];return e[0]=u*b+i*on+y*cn+T*wn,e[1]=p*b+w*on+S*cn+L*wn,e[2]=_*b+h*on+R*cn+K*wn,e[3]=s*b+x*on+V*cn+j*wn,e[4]=u*Mn+i*Dn+y*xn+T*yn,e[5]=p*Mn+w*Dn+S*xn+L*yn,e[6]=_*Mn+h*Dn+R*xn+K*yn,e[7]=s*Mn+x*Dn+V*xn+j*yn,e[8]=u*_n+i*An+y*mn+T*Tn,e[9]=p*_n+w*An+S*mn+L*Tn,e[10]=_*_n+h*An+R*mn+K*Tn,e[11]=s*_n+x*An+V*mn+j*Tn,e[12]=u*Ln+i*Hn+y*Vn+T*In,e[13]=p*Ln+w*Hn+S*Vn+L*In,e[14]=_*Ln+h*Hn+R*Vn+K*In,e[15]=s*Ln+x*Hn+V*Vn+j*In,e}const qn=On;function dn(n,o,t){const e=t??an();return n!==e&&(e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11]),e[12]=o[0],e[13]=o[1],e[14]=o[2],e[15]=1,e}function en(n,o){const t=o??D.create();return t[0]=n[12],t[1]=n[13],t[2]=n[14],t}function pn(n,o,t){const e=t??D.create(),u=o*4;return e[0]=n[u+0],e[1]=n[u+1],e[2]=n[u+2],e}function zn(n,o,t,e){const u=e===n?e:un(n,e),p=t*4;return u[p+0]=o[0],u[p+1]=o[1],u[p+2]=o[2],u}function gn(n,o){const t=o??D.create(),e=n[0],u=n[1],p=n[2],_=n[4],s=n[5],i=n[6],w=n[8],h=n[9],x=n[10];return t[0]=Math.sqrt(e*e+u*u+p*p),t[1]=Math.sqrt(_*_+s*s+i*i),t[2]=Math.sqrt(w*w+h*h+x*x),t}function Y(n,o,t,e,u){const p=u??new a(16),_=Math.tan(Math.PI*.5-.5*n);if(p[0]=_/o,p[1]=0,p[2]=0,p[3]=0,p[4]=0,p[5]=_,p[6]=0,p[7]=0,p[8]=0,p[9]=0,p[11]=-1,p[12]=0,p[13]=0,p[15]=0,Number.isFinite(e)){const s=1/(t-e);p[10]=e*s,p[14]=e*t*s}else p[10]=-1,p[14]=-t;return p}function X(n,o,t,e=1/0,u){const p=u??new a(16),_=1/Math.tan(n*.5);if(p[0]=_/o,p[1]=0,p[2]=0,p[3]=0,p[4]=0,p[5]=_,p[6]=0,p[7]=0,p[8]=0,p[9]=0,p[11]=-1,p[12]=0,p[13]=0,p[15]=0,e===1/0)p[10]=0,p[14]=t;else{const s=1/(e-t);p[10]=t*s,p[14]=e*t*s}return p}function fn(n,o,t,e,u,p,_){const s=_??new a(16);return s[0]=2/(o-n),s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=2/(e-t),s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=1/(u-p),s[11]=0,s[12]=(o+n)/(n-o),s[13]=(e+t)/(t-e),s[14]=u/(u-p),s[15]=1,s}function C(n,o,t,e,u,p,_){const s=_??new a(16),i=o-n,w=e-t,h=u-p;return s[0]=2*u/i,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=2*u/w,s[6]=0,s[7]=0,s[8]=(n+o)/i,s[9]=(e+t)/w,s[10]=p/h,s[11]=-1,s[12]=0,s[13]=0,s[14]=u*p/h,s[15]=0,s}function ln(n,o,t,e,u,p=1/0,_){const s=_??new a(16),i=o-n,w=e-t;if(s[0]=2*u/i,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=2*u/w,s[6]=0,s[7]=0,s[8]=(n+o)/i,s[9]=(e+t)/w,s[11]=-1,s[12]=0,s[13]=0,s[15]=0,p===1/0)s[10]=0,s[14]=u;else{const h=1/(p-u);s[10]=u*h,s[14]=p*u*h}return s}const U=D.create(),Q=D.create(),G=D.create();function f(n,o,t,e){const u=e??new a(16);return D.normalize(D.subtract(o,n,G),G),D.normalize(D.cross(t,G,U),U),D.normalize(D.cross(G,U,Q),Q),u[0]=U[0],u[1]=U[1],u[2]=U[2],u[3]=0,u[4]=Q[0],u[5]=Q[1],u[6]=Q[2],u[7]=0,u[8]=G[0],u[9]=G[1],u[10]=G[2],u[11]=0,u[12]=n[0],u[13]=n[1],u[14]=n[2],u[15]=1,u}function z(n,o,t,e){const u=e??new a(16);return D.normalize(D.subtract(n,o,G),G),D.normalize(D.cross(t,G,U),U),D.normalize(D.cross(G,U,Q),Q),u[0]=U[0],u[1]=U[1],u[2]=U[2],u[3]=0,u[4]=Q[0],u[5]=Q[1],u[6]=Q[2],u[7]=0,u[8]=G[0],u[9]=G[1],u[10]=G[2],u[11]=0,u[12]=n[0],u[13]=n[1],u[14]=n[2],u[15]=1,u}function M(n,o,t,e){const u=e??new a(16);return D.normalize(D.subtract(n,o,G),G),D.normalize(D.cross(t,G,U),U),D.normalize(D.cross(G,U,Q),Q),u[0]=U[0],u[1]=Q[0],u[2]=G[0],u[3]=0,u[4]=U[1],u[5]=Q[1],u[6]=G[1],u[7]=0,u[8]=U[2],u[9]=Q[2],u[10]=G[2],u[11]=0,u[12]=-(U[0]*n[0]+U[1]*n[1]+U[2]*n[2]),u[13]=-(Q[0]*n[0]+Q[1]*n[1]+Q[2]*n[2]),u[14]=-(G[0]*n[0]+G[1]*n[1]+G[2]*n[2]),u[15]=1,u}function v(n,o){const t=o??new a(16);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t}function E(n,o,t){const e=t??new a(16),u=o[0],p=o[1],_=o[2],s=n[0],i=n[1],w=n[2],h=n[3],x=n[1*4+0],y=n[1*4+1],S=n[1*4+2],R=n[1*4+3],V=n[2*4+0],T=n[2*4+1],L=n[2*4+2],K=n[2*4+3],j=n[3*4+0],b=n[3*4+1],on=n[3*4+2],cn=n[3*4+3];return n!==e&&(e[0]=s,e[1]=i,e[2]=w,e[3]=h,e[4]=x,e[5]=y,e[6]=S,e[7]=R,e[8]=V,e[9]=T,e[10]=L,e[11]=K),e[12]=s*u+x*p+V*_+j,e[13]=i*u+y*p+T*_+b,e[14]=w*u+S*p+L*_+on,e[15]=h*u+R*p+K*_+cn,e}function m(n,o){const t=o??new a(16),e=Math.cos(n),u=Math.sin(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=u,t[7]=0,t[8]=0,t[9]=-u,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function N(n,o,t){const e=t??new a(16),u=n[4],p=n[5],_=n[6],s=n[7],i=n[8],w=n[9],h=n[10],x=n[11],y=Math.cos(o),S=Math.sin(o);return e[4]=y*u+S*i,e[5]=y*p+S*w,e[6]=y*_+S*h,e[7]=y*s+S*x,e[8]=y*i-S*u,e[9]=y*w-S*p,e[10]=y*h-S*_,e[11]=y*x-S*s,n!==e&&(e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}function F(n,o){const t=o??new a(16),e=Math.cos(n),u=Math.sin(n);return t[0]=e,t[1]=0,t[2]=-u,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=u,t[9]=0,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function $(n,o,t){const e=t??new a(16),u=n[0*4+0],p=n[0*4+1],_=n[0*4+2],s=n[0*4+3],i=n[2*4+0],w=n[2*4+1],h=n[2*4+2],x=n[2*4+3],y=Math.cos(o),S=Math.sin(o);return e[0]=y*u-S*i,e[1]=y*p-S*w,e[2]=y*_-S*h,e[3]=y*s-S*x,e[8]=y*i+S*u,e[9]=y*w+S*p,e[10]=y*h+S*_,e[11]=y*x+S*s,n!==e&&(e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}function q(n,o){const t=o??new a(16),e=Math.cos(n),u=Math.sin(n);return t[0]=e,t[1]=u,t[2]=0,t[3]=0,t[4]=-u,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function H(n,o,t){const e=t??new a(16),u=n[0*4+0],p=n[0*4+1],_=n[0*4+2],s=n[0*4+3],i=n[1*4+0],w=n[1*4+1],h=n[1*4+2],x=n[1*4+3],y=Math.cos(o),S=Math.sin(o);return e[0]=y*u+S*i,e[1]=y*p+S*w,e[2]=y*_+S*h,e[3]=y*s+S*x,e[4]=y*i-S*u,e[5]=y*w-S*p,e[6]=y*h-S*_,e[7]=y*x-S*s,n!==e&&(e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}function k(n,o,t){const e=t??new a(16);let u=n[0],p=n[1],_=n[2];const s=Math.sqrt(u*u+p*p+_*_);u/=s,p/=s,_/=s;const i=u*u,w=p*p,h=_*_,x=Math.cos(o),y=Math.sin(o),S=1-x;return e[0]=i+(1-i)*x,e[1]=u*p*S+_*y,e[2]=u*_*S-p*y,e[3]=0,e[4]=u*p*S-_*y,e[5]=w+(1-w)*x,e[6]=p*_*S+u*y,e[7]=0,e[8]=u*_*S+p*y,e[9]=p*_*S-u*y,e[10]=h+(1-h)*x,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}const g=k;function O(n,o,t,e){const u=e??new a(16);let p=o[0],_=o[1],s=o[2];const i=Math.sqrt(p*p+_*_+s*s);p/=i,_/=i,s/=i;const w=p*p,h=_*_,x=s*s,y=Math.cos(t),S=Math.sin(t),R=1-y,V=w+(1-w)*y,T=p*_*R+s*S,L=p*s*R-_*S,K=p*_*R-s*S,j=h+(1-h)*y,b=_*s*R+p*S,on=p*s*R+_*S,cn=_*s*R-p*S,wn=x+(1-x)*y,Mn=n[0],Dn=n[1],xn=n[2],yn=n[3],_n=n[4],An=n[5],mn=n[6],Tn=n[7],Ln=n[8],Hn=n[9],Vn=n[10],In=n[11];return u[0]=V*Mn+T*_n+L*Ln,u[1]=V*Dn+T*An+L*Hn,u[2]=V*xn+T*mn+L*Vn,u[3]=V*yn+T*Tn+L*In,u[4]=K*Mn+j*_n+b*Ln,u[5]=K*Dn+j*An+b*Hn,u[6]=K*xn+j*mn+b*Vn,u[7]=K*yn+j*Tn+b*In,u[8]=on*Mn+cn*_n+wn*Ln,u[9]=on*Dn+cn*An+wn*Hn,u[10]=on*xn+cn*mn+wn*Vn,u[11]=on*yn+cn*Tn+wn*In,n!==u&&(u[12]=n[12],u[13]=n[13],u[14]=n[14],u[15]=n[15]),u}const c=O;function r(n,o){const t=o??new a(16);return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function l(n,o,t){const e=t??new a(16),u=o[0],p=o[1],_=o[2];return e[0]=u*n[0*4+0],e[1]=u*n[0*4+1],e[2]=u*n[0*4+2],e[3]=u*n[0*4+3],e[4]=p*n[1*4+0],e[5]=p*n[1*4+1],e[6]=p*n[1*4+2],e[7]=p*n[1*4+3],e[8]=_*n[2*4+0],e[9]=_*n[2*4+1],e[10]=_*n[2*4+2],e[11]=_*n[2*4+3],n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}function d(n,o){const t=o??new a(16);return t[0]=n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function A(n,o,t){const e=t??new a(16);return e[0]=o*n[0*4+0],e[1]=o*n[0*4+1],e[2]=o*n[0*4+2],e[3]=o*n[0*4+3],e[4]=o*n[1*4+0],e[5]=o*n[1*4+1],e[6]=o*n[1*4+2],e[7]=o*n[1*4+3],e[8]=o*n[2*4+0],e[9]=o*n[2*4+1],e[10]=o*n[2*4+2],e[11]=o*n[2*4+3],n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e}return{create:P,set:B,fromMat3:W,fromQuat:Z,negate:nn,copy:un,clone:Sn,equalsApproximately:En,equals:Pn,identity:an,transpose:tn,inverse:sn,determinant:Rn,invert:hn,multiply:On,mul:qn,setTranslation:dn,getTranslation:en,getAxis:pn,setAxis:zn,getScaling:gn,perspective:Y,perspectiveReverseZ:X,ortho:fn,frustum:C,frustumReverseZ:ln,aim:f,cameraAim:z,lookAt:M,translation:v,translate:E,rotationX:m,rotateX:N,rotationY:F,rotateY:$,rotationZ:q,rotateZ:H,axisRotation:k,rotation:g,axisRotate:O,rotate:c,scaling:r,scale:l,uniformScaling:d,uniformScale:A}}const at=new Map;function Rt(a){let D=at.get(a);return D||(D=Pt(a),at.set(a,D)),D}function qt(a){const D=bn(a);function P(g,O,c,r){const l=new a(4);return g!==void 0&&(l[0]=g,O!==void 0&&(l[1]=O,c!==void 0&&(l[2]=c,r!==void 0&&(l[3]=r)))),l}const B=P;function W(g,O,c,r,l){const d=l??new a(4);return d[0]=g,d[1]=O,d[2]=c,d[3]=r,d}function Z(g,O,c){const r=c??new a(4),l=O*.5,d=Math.sin(l);return r[0]=d*g[0],r[1]=d*g[1],r[2]=d*g[2],r[3]=Math.cos(l),r}function nn(g,O){const c=O??D.create(3),r=Math.acos(g[3])*2,l=Math.sin(r*.5);return l>I?(c[0]=g[0]/l,c[1]=g[1]/l,c[2]=g[2]/l):(c[0]=1,c[1]=0,c[2]=0),{angle:r,axis:c}}function un(g,O){const c=C(g,O);return Math.acos(2*c*c-1)}function Sn(g,O,c){const r=c??new a(4),l=g[0],d=g[1],A=g[2],n=g[3],o=O[0],t=O[1],e=O[2],u=O[3];return r[0]=l*u+n*o+d*e-A*t,r[1]=d*u+n*t+A*o-l*e,r[2]=A*u+n*e+l*t-d*o,r[3]=n*u-l*o-d*t-A*e,r}const En=Sn;function Pn(g,O,c){const r=c??new a(4),l=O*.5,d=g[0],A=g[1],n=g[2],o=g[3],t=Math.sin(l),e=Math.cos(l);return r[0]=d*e+o*t,r[1]=A*e+n*t,r[2]=n*e-A*t,r[3]=o*e-d*t,r}function an(g,O,c){const r=c??new a(4),l=O*.5,d=g[0],A=g[1],n=g[2],o=g[3],t=Math.sin(l),e=Math.cos(l);return r[0]=d*e-n*t,r[1]=A*e+o*t,r[2]=n*e+d*t,r[3]=o*e-A*t,r}function tn(g,O,c){const r=c??new a(4),l=O*.5,d=g[0],A=g[1],n=g[2],o=g[3],t=Math.sin(l),e=Math.cos(l);return r[0]=d*e+A*t,r[1]=A*e-d*t,r[2]=n*e+o*t,r[3]=o*e-n*t,r}function sn(g,O,c,r){const l=r??new a(4),d=g[0],A=g[1],n=g[2],o=g[3];let t=O[0],e=O[1],u=O[2],p=O[3],_=d*t+A*e+n*u+o*p;_<0&&(_=-_,t=-t,e=-e,u=-u,p=-p);let s,i;if(1-_>I){const w=Math.acos(_),h=Math.sin(w);s=Math.sin((1-c)*w)/h,i=Math.sin(c*w)/h}else s=1-c,i=c;return l[0]=s*d+i*t,l[1]=s*A+i*e,l[2]=s*n+i*u,l[3]=s*o+i*p,l}function Rn(g,O){const c=O??new a(4),r=g[0],l=g[1],d=g[2],A=g[3],n=r*r+l*l+d*d+A*A,o=n?1/n:0;return c[0]=-r*o,c[1]=-l*o,c[2]=-d*o,c[3]=A*o,c}function hn(g,O){const c=O??new a(4);return c[0]=-g[0],c[1]=-g[1],c[2]=-g[2],c[3]=g[3],c}function On(g,O){const c=O??new a(4),r=g[0]+g[5]+g[10];if(r>0){const l=Math.sqrt(r+1);c[3]=.5*l;const d=.5/l;c[0]=(g[6]-g[9])*d,c[1]=(g[8]-g[2])*d,c[2]=(g[1]-g[4])*d}else{let l=0;g[5]>g[0]&&(l=1),g[10]>g[l*4+l]&&(l=2);const d=(l+1)%3,A=(l+2)%3,n=Math.sqrt(g[l*4+l]-g[d*4+d]-g[A*4+A]+1);c[l]=.5*n;const o=.5/n;c[3]=(g[d*4+A]-g[A*4+d])*o,c[d]=(g[d*4+l]+g[l*4+d])*o,c[A]=(g[A*4+l]+g[l*4+A])*o}return c}function qn(g,O,c,r,l){const d=l??new a(4),A=g*.5,n=O*.5,o=c*.5,t=Math.sin(A),e=Math.cos(A),u=Math.sin(n),p=Math.cos(n),_=Math.sin(o),s=Math.cos(o);switch(r){case"xyz":d[0]=t*p*s+e*u*_,d[1]=e*u*s-t*p*_,d[2]=e*p*_+t*u*s,d[3]=e*p*s-t*u*_;break;case"xzy":d[0]=t*p*s-e*u*_,d[1]=e*u*s-t*p*_,d[2]=e*p*_+t*u*s,d[3]=e*p*s+t*u*_;break;case"yxz":d[0]=t*p*s+e*u*_,d[1]=e*u*s-t*p*_,d[2]=e*p*_-t*u*s,d[3]=e*p*s+t*u*_;break;case"yzx":d[0]=t*p*s+e*u*_,d[1]=e*u*s+t*p*_,d[2]=e*p*_-t*u*s,d[3]=e*p*s-t*u*_;break;case"zxy":d[0]=t*p*s-e*u*_,d[1]=e*u*s+t*p*_,d[2]=e*p*_+t*u*s,d[3]=e*p*s-t*u*_;break;case"zyx":d[0]=t*p*s-e*u*_,d[1]=e*u*s+t*p*_,d[2]=e*p*_-t*u*s,d[3]=e*p*s+t*u*_;break;default:throw new Error(`Unknown rotation order: ${r}`)}return d}function dn(g,O){const c=O??new a(4);return c[0]=g[0],c[1]=g[1],c[2]=g[2],c[3]=g[3],c}const en=dn;function pn(g,O,c){const r=c??new a(4);return r[0]=g[0]+O[0],r[1]=g[1]+O[1],r[2]=g[2]+O[2],r[3]=g[3]+O[3],r}function zn(g,O,c){const r=c??new a(4);return r[0]=g[0]-O[0],r[1]=g[1]-O[1],r[2]=g[2]-O[2],r[3]=g[3]-O[3],r}const gn=zn;function Y(g,O,c){const r=c??new a(4);return r[0]=g[0]*O,r[1]=g[1]*O,r[2]=g[2]*O,r[3]=g[3]*O,r}const X=Y;function fn(g,O,c){const r=c??new a(4);return r[0]=g[0]/O,r[1]=g[1]/O,r[2]=g[2]/O,r[3]=g[3]/O,r}function C(g,O){return g[0]*O[0]+g[1]*O[1]+g[2]*O[2]+g[3]*O[3]}function ln(g,O,c,r){const l=r??new a(4);return l[0]=g[0]+c*(O[0]-g[0]),l[1]=g[1]+c*(O[1]-g[1]),l[2]=g[2]+c*(O[2]-g[2]),l[3]=g[3]+c*(O[3]-g[3]),l}function U(g){const O=g[0],c=g[1],r=g[2],l=g[3];return Math.sqrt(O*O+c*c+r*r+l*l)}const Q=U;function G(g){const O=g[0],c=g[1],r=g[2],l=g[3];return O*O+c*c+r*r+l*l}const f=G;function z(g,O){const c=O??new a(4),r=g[0],l=g[1],d=g[2],A=g[3],n=Math.sqrt(r*r+l*l+d*d+A*A);return n>1e-5?(c[0]=r/n,c[1]=l/n,c[2]=d/n,c[3]=A/n):(c[0]=0,c[1]=0,c[2]=0,c[3]=1),c}function M(g,O){return Math.abs(g[0]-O[0])<I&&Math.abs(g[1]-O[1])<I&&Math.abs(g[2]-O[2])<I&&Math.abs(g[3]-O[3])<I}function v(g,O){return g[0]===O[0]&&g[1]===O[1]&&g[2]===O[2]&&g[3]===O[3]}function E(g){const O=g??new a(4);return O[0]=0,O[1]=0,O[2]=0,O[3]=1,O}const m=D.create(),N=D.create(),F=D.create();function $(g,O,c){const r=c??new a(4),l=D.dot(g,O);return l<-.999999?(D.cross(N,g,m),D.len(m)<1e-6&&D.cross(F,g,m),D.normalize(m,m),Z(m,Math.PI,r),r):l>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(D.cross(g,O,m),r[0]=m[0],r[1]=m[1],r[2]=m[2],r[3]=1+l,z(r,r))}const q=new a(4),H=new a(4);function k(g,O,c,r,l,d){const A=d??new a(4);return sn(g,r,l,q),sn(O,c,l,H),sn(q,H,2*l*(1-l),A),A}return{create:P,fromValues:B,set:W,fromAxisAngle:Z,toAxisAngle:nn,angle:un,multiply:Sn,mul:En,rotateX:Pn,rotateY:an,rotateZ:tn,slerp:sn,inverse:Rn,conjugate:hn,fromMat:On,fromEuler:qn,copy:dn,clone:en,add:pn,subtract:zn,sub:gn,mulScalar:Y,scale:X,divScalar:fn,dot:C,lerp:ln,length:U,len:Q,lengthSq:G,lenSq:f,normalize:z,equalsApproximately:M,equals:v,identity:E,rotationTo:$,sqlerp:k}}const ft=new Map;function Ht(a){let D=ft.get(a);return D||(D=qt(a),ft.set(a,D)),D}function Vt(a){function D(c,r,l,d){const A=new a(4);return c!==void 0&&(A[0]=c,r!==void 0&&(A[1]=r,l!==void 0&&(A[2]=l,d!==void 0&&(A[3]=d)))),A}const P=D;function B(c,r,l,d,A){const n=A??new a(4);return n[0]=c,n[1]=r,n[2]=l,n[3]=d,n}function W(c,r){const l=r??new a(4);return l[0]=Math.ceil(c[0]),l[1]=Math.ceil(c[1]),l[2]=Math.ceil(c[2]),l[3]=Math.ceil(c[3]),l}function Z(c,r){const l=r??new a(4);return l[0]=Math.floor(c[0]),l[1]=Math.floor(c[1]),l[2]=Math.floor(c[2]),l[3]=Math.floor(c[3]),l}function nn(c,r){const l=r??new a(4);return l[0]=Math.round(c[0]),l[1]=Math.round(c[1]),l[2]=Math.round(c[2]),l[3]=Math.round(c[3]),l}function un(c,r=0,l=1,d){const A=d??new a(4);return A[0]=Math.min(l,Math.max(r,c[0])),A[1]=Math.min(l,Math.max(r,c[1])),A[2]=Math.min(l,Math.max(r,c[2])),A[3]=Math.min(l,Math.max(r,c[3])),A}function Sn(c,r,l){const d=l??new a(4);return d[0]=c[0]+r[0],d[1]=c[1]+r[1],d[2]=c[2]+r[2],d[3]=c[3]+r[3],d}function En(c,r,l,d){const A=d??new a(4);return A[0]=c[0]+r[0]*l,A[1]=c[1]+r[1]*l,A[2]=c[2]+r[2]*l,A[3]=c[3]+r[3]*l,A}function Pn(c,r,l){const d=l??new a(4);return d[0]=c[0]-r[0],d[1]=c[1]-r[1],d[2]=c[2]-r[2],d[3]=c[3]-r[3],d}const an=Pn;function tn(c,r){return Math.abs(c[0]-r[0])<I&&Math.abs(c[1]-r[1])<I&&Math.abs(c[2]-r[2])<I&&Math.abs(c[3]-r[3])<I}function sn(c,r){return c[0]===r[0]&&c[1]===r[1]&&c[2]===r[2]&&c[3]===r[3]}function Rn(c,r,l,d){const A=d??new a(4);return A[0]=c[0]+l*(r[0]-c[0]),A[1]=c[1]+l*(r[1]-c[1]),A[2]=c[2]+l*(r[2]-c[2]),A[3]=c[3]+l*(r[3]-c[3]),A}function hn(c,r,l,d){const A=d??new a(4);return A[0]=c[0]+l[0]*(r[0]-c[0]),A[1]=c[1]+l[1]*(r[1]-c[1]),A[2]=c[2]+l[2]*(r[2]-c[2]),A[3]=c[3]+l[3]*(r[3]-c[3]),A}function On(c,r,l){const d=l??new a(4);return d[0]=Math.max(c[0],r[0]),d[1]=Math.max(c[1],r[1]),d[2]=Math.max(c[2],r[2]),d[3]=Math.max(c[3],r[3]),d}function qn(c,r,l){const d=l??new a(4);return d[0]=Math.min(c[0],r[0]),d[1]=Math.min(c[1],r[1]),d[2]=Math.min(c[2],r[2]),d[3]=Math.min(c[3],r[3]),d}function dn(c,r,l){const d=l??new a(4);return d[0]=c[0]*r,d[1]=c[1]*r,d[2]=c[2]*r,d[3]=c[3]*r,d}const en=dn;function pn(c,r,l){const d=l??new a(4);return d[0]=c[0]/r,d[1]=c[1]/r,d[2]=c[2]/r,d[3]=c[3]/r,d}function zn(c,r){const l=r??new a(4);return l[0]=1/c[0],l[1]=1/c[1],l[2]=1/c[2],l[3]=1/c[3],l}const gn=zn;function Y(c,r){return c[0]*r[0]+c[1]*r[1]+c[2]*r[2]+c[3]*r[3]}function X(c){const r=c[0],l=c[1],d=c[2],A=c[3];return Math.sqrt(r*r+l*l+d*d+A*A)}const fn=X;function C(c){const r=c[0],l=c[1],d=c[2],A=c[3];return r*r+l*l+d*d+A*A}const ln=C;function U(c,r){const l=c[0]-r[0],d=c[1]-r[1],A=c[2]-r[2],n=c[3]-r[3];return Math.sqrt(l*l+d*d+A*A+n*n)}const Q=U;function G(c,r){const l=c[0]-r[0],d=c[1]-r[1],A=c[2]-r[2],n=c[3]-r[3];return l*l+d*d+A*A+n*n}const f=G;function z(c,r){const l=r??new a(4),d=c[0],A=c[1],n=c[2],o=c[3],t=Math.sqrt(d*d+A*A+n*n+o*o);return t>1e-5?(l[0]=d/t,l[1]=A/t,l[2]=n/t,l[3]=o/t):(l[0]=0,l[1]=0,l[2]=0,l[3]=0),l}function M(c,r){const l=r??new a(4);return l[0]=-c[0],l[1]=-c[1],l[2]=-c[2],l[3]=-c[3],l}function v(c,r){const l=r??new a(4);return l[0]=c[0],l[1]=c[1],l[2]=c[2],l[3]=c[3],l}const E=v;function m(c,r,l){const d=l??new a(4);return d[0]=c[0]*r[0],d[1]=c[1]*r[1],d[2]=c[2]*r[2],d[3]=c[3]*r[3],d}const N=m;function F(c,r,l){const d=l??new a(4);return d[0]=c[0]/r[0],d[1]=c[1]/r[1],d[2]=c[2]/r[2],d[3]=c[3]/r[3],d}const $=F;function q(c){const r=c??new a(4);return r[0]=0,r[1]=0,r[2]=0,r[3]=0,r}function H(c,r,l){const d=l??new a(4),A=c[0],n=c[1],o=c[2],t=c[3];return d[0]=r[0]*A+r[4]*n+r[8]*o+r[12]*t,d[1]=r[1]*A+r[5]*n+r[9]*o+r[13]*t,d[2]=r[2]*A+r[6]*n+r[10]*o+r[14]*t,d[3]=r[3]*A+r[7]*n+r[11]*o+r[15]*t,d}function k(c,r,l){const d=l??new a(4);return z(c,d),dn(d,r,d)}function g(c,r,l){const d=l??new a(4);return X(c)>r?k(c,r,d):v(c,d)}function O(c,r,l){const d=l??new a(4);return Rn(c,r,.5,d)}return{create:D,fromValues:P,set:B,ceil:W,floor:Z,round:nn,clamp:un,add:Sn,addScaled:En,subtract:Pn,sub:an,equalsApproximately:tn,equals:sn,lerp:Rn,lerpV:hn,max:On,min:qn,mulScalar:dn,scale:en,divScalar:pn,inverse:zn,invert:gn,dot:Y,length:X,len:fn,lengthSq:C,lenSq:ln,distance:U,dist:Q,distanceSq:G,distSq:f,normalize:z,negate:M,copy:v,clone:E,multiply:m,mul:N,divide:F,div:$,zero:q,transformMat4:H,setLength:k,truncate:g,midpoint:O}}const lt=new Map;function It(a){let D=lt.get(a);return D||(D=Vt(a),lt.set(a,D)),D}function Cn(a,D,P,B,W,Z){return{mat4:Rt(a),mat3:Lt(D),quat:Ht(P),vec2:pt(B),vec3:bn(W),vec4:It(Z)}}const{mat4:Wn,vec2:Bt,vec3:Bn,vec4:rn}=Cn(Float32Array,Float32Array,Float32Array,Float32Array,Float32Array,Float32Array);Cn(Float64Array,Float64Array,Float64Array,Float64Array,Float64Array,Float64Array);Cn(yt,Array,Array,Array,Array,Array);const Nt=`struct Uniforms {
  projectionMatrix : mat4x4f,
  modelViewMatrix : mat4x4f,
  fogColor : vec4f,
  lightDirection : vec4f,
  cameraPosition: vec4f,
  config : vec4f,
}
@binding(0) @group(0) var<uniform> uniforms : Uniforms;

struct VertexOut {
  @builtin(position) position : vec4f,
  @location(0) color : vec4f,
  @location(1) normal : vec3f,
  @location(2) fogDepth : f32
}

const WATER_COLOR = vec4(0.06, 0.37, 0.61, 1.0);
const SAND_COLOR = vec4(0.8, 0.52, 0.24, 1.0);
const GRASS_COLOR = vec4(0.13, 0.53, 0.0, 1.0);
const STONE_COLOR = vec4(0.65, 0.65, 0.65, 1.0);
const SNOW_COLOR = vec4(1.0, 1.0, 1.0, 1.0);

const WATER_THRESHOLD = 0.5;
const SAND_THRESHOLD = 0.51;
const GRASS_THRESHOLD = 0.55;
const STONE_THRESHOLD = 0.85;
const SNOW_THRESHOLD = 1.0;

const normalOffsetDelta = 0.032;

const terrainFractalLayers = 5;
const terrainAmplitudeFreq = 0.3;
const waveScale = 0.1;

const uLightDiffuse = vec4f(1.0, 1.0, 1.0, 1.0);

// Phong Light Model
// https://github.com/PacktPublishing/Real-Time-3D-Graphics-with-WebGL-2/blob/master/ch03/ch03_04_sphere-phong.html
fn light(normal: vec3f, materialDiffuse: vec4f, vertex: vec3f) -> vec4f {
  // Normalized light direction
  let L = normalize(uniforms.lightDirection.xyz);

  // Normalized normal
  let N = normalize(normal);

  let lambertTerm = dot(N, -L);
  if (lambertTerm > 0.0) {
    var Id = vec4f(uLightDiffuse * materialDiffuse * lambertTerm);
    return vec4f(Id.xyz, 1.0);
  } else {
    return vec4f(0.0, 0.0, 0.0, 1.0);
  }
}

fn randomGradient(p: vec2f, seed: f32) -> vec2f {
  let x = dot(p, vec2(123.4, 234.5));
  let y = dot(p, vec2(234.5, 345.6));
  var gradient = vec2(x, y);
  gradient = sin(gradient);
  gradient = gradient * 43758.5453 + seed;

  gradient = sin(gradient);
  return gradient;
}

fn quintic(p: vec2f) -> vec2f {
  return p * p * p * (10.0 + p * (-15.0 + p * 6.0));
}

// Perlin Noise
// https://github.com/SuboptimalEng/shader-tutorials/blob/main/05-perlin-noise/shader.frag
fn perlin(p: vec2f, seed: f32) -> f32 {
  // set up a grid of cells
  let gridId = floor(p);
  var gridUv = fract(p);

  // start by finding the coords of grid corners
  let bl = gridId + vec2f(0.0, 0.0);
  let br = gridId + vec2f(1.0, 0.0);
  let tl = gridId + vec2f(0.0, 1.0);
  let tr = gridId + vec2f(1.0, 1.0);

  // find random gradient for each grid corner
  let gradBl = randomGradient(bl, seed);
  let gradBr = randomGradient(br, seed);
  let gradTl = randomGradient(tl, seed);
  let gradTr = randomGradient(tr, seed);

  // find distance from current pixel to each grid corner
  let distFromPixelToBl = gridUv - vec2f(0.0, 0.0);
  let distFromPixelToBr = gridUv - vec2f(1.0, 0.0);
  let distFromPixelToTl = gridUv - vec2f(0.0, 1.0);
  let distFromPixelToTr = gridUv - vec2f(1.0, 1.0);

  // calculate the dot products of gradients + distances
  let dotBl = dot(gradBl, distFromPixelToBl);
  let dotBr = dot(gradBr, distFromPixelToBr);
  let dotTl = dot(gradTl, distFromPixelToTl);
  let dotTr = dot(gradTr, distFromPixelToTr);

  // smooth out gridUvs
  gridUv = quintic(gridUv);

  // perform linear interpolation between 4 dot products
  let b = mix(dotBl, dotBr, gridUv.x);
  let t = mix(dotTl, dotTr, gridUv.x);
  return mix(b, t, gridUv.y) / 2.0 + 0.5;
}

// Fractal Perlin Noise
fn terrainHeight(p: vec2f) -> f32 {
  let animationsOn = uniforms.config.w;
  let time = uniforms.config.x;
  var fractal = 0.0;
  var amplitude = 1.0;
  var pt = p;
  for (var i = 0; i < terrainFractalLayers; i++) {
    let seed = animationsOn * (f32(terrainFractalLayers - i) + time);
    fractal += perlin(pt, seed) * amplitude;
    pt *= 2.0;
    amplitude *= terrainAmplitudeFreq;
  }
  return fractal;
}

// Generate normal from perlin noise using derivatives
// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/perlin-noise-part-2/perlin-noise-computing-derivatives.html
fn terrainNormal(position: vec2f, noise_value: f32) -> vec3f {
  // point a bit to the right of the original value
  let position_offset_x = position.xy + vec2f(normalOffsetDelta, 0.0);
  // what is its noise value
  let noise_offset_x = terrainHeight(position_offset_x);
  // a vector from the point to the other one, using the noise result
  // as the third dimension
  let tangent_x = normalize(vec3f(position.xy, noise_value) - vec3f(position_offset_x, noise_offset_x));

  // same for Y
  let position_offset_y = position.xy + vec2f(0.0, normalOffsetDelta);
  let noise_offset_y = terrainHeight(position_offset_y);
  let tangent_y = normalize(vec3f(position.xy, noise_value) - vec3f(position_offset_y, noise_offset_y));

  // cross product of the two tangents of the point will create
  // the normal vector at that point
  return cross(tangent_x, tangent_y);
}

fn water(position: vec2f, t: f32) -> f32 {
  let x = position.x;
  let z = position.y;
  let scale = waveScale;
  let x_wave = (
    sin(x * 1.0 / scale + t * 1.0) +
    sin(x * 2.3 / scale + t * 1.5) +
    sin(x * 3.3 / scale + t * 0.4)
  ) / 3.0;
  let z_wave = (
    sin(z * 0.2 / scale + t * 1.8) +
    sin(z * 1.8 / scale + t * 1.8) +
    sin(z * 2.8 / scale + t * 0.8)
  ) / 3.0;
  return WATER_THRESHOLD + (x_wave + z_wave + 2.0) / 100.0;
}

fn waterNormal(position: vec2f, wave_value: f32, time: f32) -> vec3f {
  let position_offset_x = position.xy + vec2f(normalOffsetDelta, 0.0);
  let wave_offset_x = water(position_offset_x, time);
  let tangent_x = normalize(vec3f(position.xy, wave_value) - vec3f(position_offset_x, wave_offset_x));

  let position_offset_y = position.xy + vec2f(0.0, normalOffsetDelta);
  let wave_offset_y = water(position_offset_y, time);
  let tangent_y = normalize(vec3f(position.xy, wave_value) - vec3f(position_offset_y, wave_offset_y));

  return cross(tangent_x, tangent_y);
}

fn terrainColor(z: f32) -> vec4f {
  if(z < WATER_THRESHOLD) {
    return WATER_COLOR;
  } else if(z < SAND_THRESHOLD) {
    return mix(WATER_COLOR, SAND_COLOR, (z - WATER_THRESHOLD) / (SAND_THRESHOLD - WATER_THRESHOLD));
  } else if(z < GRASS_THRESHOLD) {
    return mix(SAND_COLOR, GRASS_COLOR, (z - SAND_THRESHOLD) / (GRASS_THRESHOLD - SAND_THRESHOLD));
  } else if(z < STONE_THRESHOLD) {
    return mix(GRASS_COLOR, STONE_COLOR, (z - GRASS_THRESHOLD) / (STONE_THRESHOLD - GRASS_THRESHOLD));
  } else {
    return mix(STONE_COLOR, SNOW_COLOR, (z - STONE_THRESHOLD) / (SNOW_THRESHOLD - STONE_THRESHOLD));
  }
}

@vertex
fn vertex_main(@location(0) position: vec4f) -> VertexOut {
  let time = uniforms.config.x;

  // Offset the position by the actual camera position to simulate the camera moving
  let offset_position = position.xz + uniforms.cameraPosition.xz;
  var terrain_value = terrainHeight(offset_position);
  var color = terrainColor(terrain_value);

  var normal = vec3f(0.0, 1.0, 0.0);
  if (terrain_value < WATER_THRESHOLD) {
    terrain_value = water(offset_position, time);
    normal = waterNormal(offset_position, terrain_value, time);
  } else {
    normal = terrainNormal(offset_position, terrain_value);
  }
  let terrain_position = vec4f(position.x, terrain_value, position.z, 1.0);

  var output = VertexOut();
  output.position = uniforms.projectionMatrix * uniforms.modelViewMatrix * terrain_position;
  output.color = color;
  output.normal = normal;
  // Fog depth is the distance from the camera to the vertex
  // https://webglfundamentals.org/webgl/lessons/webgl-fog.html
  output.fogDepth = -(uniforms.modelViewMatrix * terrain_position).z;
  return output;
}

@fragment
fn fragment_main(fragData: VertexOut) -> @location(0) vec4f {
  let fogOn = uniforms.config.y == 1.0;
  let lightsOn = uniforms.config.z == 1.0;
  let color_light = light(fragData.normal, fragData.color, fragData.position.xyz);
  var color = select(fragData.color, color_light, lightsOn);
  if (!fogOn) {
    return color;
  } else {
    let fogAmount = smoothstep(2.0, 8.0, fragData.fogDepth);
    return mix(color, vec4f(0.8, 0.9, 1.0, 1.0), fogAmount);  
  }
}`;class Ft{constructor(D,P=new Float32Array([0,1,0])){J(this,"viewMatrix");J(this,"position");J(this,"front",Bn.fromValues());J(this,"up",Bn.fromValues());J(this,"worldUp",Bn.fromValues());J(this,"right",Bn.fromValues());J(this,"yaw",-90);J(this,"pitch",-30);this.position=D,this.worldUp=P,this.viewMatrix=Wn.identity(),this.updateCameraVectors()}updateCameraVectors(){this.front=Bn.normalize(Bn.fromValues(Math.cos(Gn.degToRad(this.yaw))*Math.cos(Gn.degToRad(this.pitch)),Math.sin(Gn.degToRad(this.pitch)),Math.sin(Gn.degToRad(this.yaw))*Math.cos(Gn.degToRad(this.pitch)))),this.right=Bn.normalize(Bn.cross(this.front,this.worldUp)),this.up=Bn.normalize(Bn.cross(this.right,this.front))}processControls(D,P){const B=P;D.forwardKey&&(this.position=rn.add(this.position,rn.mul(this.front,rn.fromValues(B,B,B)))),D.backwardKey&&(this.position=rn.sub(this.position,rn.mul(this.front,rn.fromValues(B,B,B)))),D.leftKey&&(this.position=rn.sub(this.position,rn.mul(this.right,rn.fromValues(B,B,B)))),D.rightKey&&(this.position=rn.add(this.position,rn.mul(this.right,rn.fromValues(B,B,B))))}processMouseMovement(D,P){D*=.5,P*=.5,this.yaw+=D,this.pitch+=P,this.pitch>89?this.pitch=89:this.pitch<-89&&(this.pitch=-89),this.updateCameraVectors()}getViewMatrix(D=new Float32Array([this.position[0],this.position[2]])){const P=Bn.fromValues(D[0],this.position[1],D[2]);return Wn.lookAt(P,Bn.add(P,this.front),this.up)}}var Fn;class Ut{constructor(){J(this,"projectionMatrix",Wn.create());J(this,"modelViewMatrix",Wn.create());J(this,"lightDirection",rn.create());J(this,"fogColor",rn.create());J(this,"cameraPosition",rn.create());J(this,"config",rn.create());J(this,"uniformBufferSize",this.projectionMatrix.byteLength+this.modelViewMatrix.byteLength+this.fogColor.byteLength+this.lightDirection.byteLength+this.cameraPosition.byteLength+this.config.byteLength);ct(this,Fn,new Float32Array(this.uniformBufferSize/4));J(this,"getBufferData",()=>{const D=[this.projectionMatrix,this.modelViewMatrix,this.fogColor,this.lightDirection,this.cameraPosition,this.config];let P=0;for(let B=0;B<D.length;B++)Un(this,Fn).set(D[B],P),P+=D[B].byteLength/4;return{data:Un(this,Fn).buffer,dataOffset:Un(this,Fn).byteOffset,size:Un(this,Fn).byteLength}})}}Fn=new WeakMap;class Gt{constructor(D,P){J(this,"forwardKey",!1);J(this,"backwardKey",!1);J(this,"leftKey",!1);J(this,"rightKey",!1);J(this,"fogOn",!0);J(this,"lightsOn",!0);J(this,"animationOn",!1);document.addEventListener("keydown",W=>{switch(W.key){case"w":this.forwardKey=!0;break;case"s":this.backwardKey=!0;break;case"a":this.leftKey=!0;break;case"d":this.rightKey=!0;break;case"1":this.fogOn=!this.fogOn;break;case"2":this.lightsOn=!this.lightsOn;break;case"3":this.animationOn=!this.animationOn;break}}),document.addEventListener("keyup",W=>{switch(W.key){case"w":this.forwardKey=!1;break;case"s":this.backwardKey=!1;break;case"a":this.leftKey=!1;break;case"d":this.rightKey=!1;break;case"Escape":D.removeEventListener("mousemove",B);break}});const B=W=>{P(W.movementX,-W.movementY)};D.addEventListener("click",()=>{D.requestPointerLock(),D.addEventListener("mousemove",B)})}}const Wt=.002,Kt=800,Nn=800,Jn=8,wt=1/(Nn-1)*(Jn*2),ht=rn.fromValues(.8,.9,1,1),Qn=rn.fromValues(0,3,0),$t=rn.fromValues(-.25,-.25,-.25,0);let dt=performance.now();const jt=async()=>{if(!navigator.gpu)throw Error("WebGPU not supported.");const a=await navigator.gpu.requestAdapter();if(!a)throw Error("Couldn't request WebGPU adapter.");const D=await a.requestDevice(),P=document.querySelector("#gpuCanvas");P.width=window.innerWidth,P.height=window.innerHeight;const B=P.getContext("webgpu"),W=[];for(let Y=-8;Y<=Jn;Y=Y+wt)for(let X=-8;X<=Jn;X=X+wt)W.push(Y,0,X);const Z=new Float32Array(W),nn=[];for(let Y=0;Y<=Nn-2;Y++)for(let X=0;X<=Nn-2;X++){const fn=Y*Nn+X,C=Y*Nn+X+1,ln=(Y+1)*Nn+X+1,U=(Y+1)*Nn+X;nn.push(fn,C,U),nn.push(C,U,ln)}const un=new Uint32Array(nn),Sn=D.createShaderModule({code:Nt});B.configure({device:D,format:navigator.gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"});const En=D.createBuffer({label:"vertex buffer",size:Z.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});D.queue.writeBuffer(En,0,Z,0,Z.length);const Pn={attributes:[{shaderLocation:0,offset:0,format:"float32x3"}],arrayStride:12,stepMode:"vertex"},an=D.createBuffer({label:"index buffer",size:un.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST});D.queue.writeBuffer(an,0,un);const tn=new Ut,sn=D.createBuffer({label:"uniform buffer",size:tn.uniformBufferSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),Rn={vertex:{module:Sn,entryPoint:"vertex_main",buffers:[Pn]},fragment:{module:Sn,entryPoint:"fragment_main",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]},primitive:{topology:"triangle-list"},layout:"auto"},hn=D.createRenderPipeline(Rn),On=D.createBindGroup({layout:hn.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:sn}}]}),qn=P.width/P.height,dn=Wn.perspective(2*Math.PI/5,qn,0,100),en=new Ft(Qn),pn=new Gt(P,(Y,X)=>en.processMouseMovement(Y,X));function zn(Y){en.processControls(pn,Y);const X=Bt.fromValues(Qn[0],Qn[2]);return en.getViewMatrix(X)}function gn(){const Y=performance.now(),X=Y-dt;dt=Y;const fn=Y/Kt%1e3,C=zn(X*Wt);tn.projectionMatrix=dn,tn.modelViewMatrix=C,tn.fogColor=ht,tn.lightDirection=$t,tn.cameraPosition=en.position,tn.config=new Float32Array([fn,pn.fogOn?1:0,pn.lightsOn?1:0,pn.animationOn?1:0]);const ln=tn.getBufferData();D.queue.writeBuffer(sn,0,ln.data,ln.dataOffset,ln.size);const[U,Q,G,f]=ht,z={colorAttachments:[{clearValue:{r:U,g:Q,b:G,a:f},loadOp:"clear",storeOp:"store",view:B.getCurrentTexture().createView()}]},M=D.createCommandEncoder(),v=M.beginRenderPass(z);v.setPipeline(hn),v.setBindGroup(0,On),v.setVertexBuffer(0,En),v.setIndexBuffer(an,"uint32"),v.drawIndexed(nn.length),v.end(),D.queue.submit([M.finish()]),requestAnimationFrame(()=>gn())}gn()};jt();
